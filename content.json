{"meta":{"title":"xmliu's blog","subtitle":null,"description":"","author":"LIU, XIMING","url":"https://lxmymjr.github.io","root":"/"},"pages":[{"title":"categories","date":"2017-09-02T15:07:18.000Z","updated":"2021-09-16T02:56:10.904Z","comments":true,"path":"categories/index.html","permalink":"https://lxmymjr.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-09-02T15:05:57.000Z","updated":"2021-09-16T02:56:10.926Z","comments":true,"path":"tags/index.html","permalink":"https://lxmymjr.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PySpark 的 DataFrame 与 Pandas 的 DataFrame 的比较","slug":"PySpark的DataFrame与Pandas的DataFrame的比较","date":"2020-10-29T09:59:28.000Z","updated":"2021-09-22T12:57:24.399Z","comments":true,"path":"contents/PySpark的DataFrame与Pandas的DataFrame的比较.html","link":"","permalink":"https://lxmymjr.github.io/contents/PySpark%E7%9A%84DataFrame%E4%B8%8EPandas%E7%9A%84DataFrame%E7%9A%84%E6%AF%94%E8%BE%83.html","excerpt":"PySpark 和 Pandas 中都有 DataFrame 这个数据结构，但是他们的使用方法大有不同。 Reference：pyspark 系列 --pandas 与 pyspark 对比 ;Pandas 和 PySpark 中的 DataFrame 比较 ;PySpark API;Pandas API","text":"PySpark 和 Pandas 中都有 DataFrame 这个数据结构，但是他们的使用方法大有不同。 Reference：pyspark 系列 --pandas 与 pyspark 对比 ;Pandas 和 PySpark 中的 DataFrame 比较 ;PySpark API;Pandas API 工作方式 PySpark 分布式并行计算框架，内建并行机制 parallelism，所有的数据和操作自动并行分布在各个集群结点上。以处理 in-memory 数据的方式处理 distributed 数据。支持 Hadoop，能处理大量数据 import pyspark.sql.functions as F 导入内置函数库 Pandas 单机 single machine tool，没有并行机制 parallelism，不支持 Hadoop，处理大量数据有瓶颈 延迟机制 PySpark lazy-evaluated Pandas not lazy-evaluated 注：在程式语言理论中，惰性求值（英语：Lazy Evaluation），又译为惰性计算、懒惰求值，也称为传需求调用（call-by-need），是一个计算机编程中的一个概念，目的是要最小化计算机要做的工作。它有两个相关而又有区别的含意，可以表示为 “延迟求值” 和 “最小化求值”。在使用延迟求值的时候，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值 内存缓存 PySpark persist () 或 cache () 将转换的 RDDs 保存在内存 Pandas 单机缓存 DataFrame 可变性 PySpark Spark 中 RDDs 是不可变的，因此 DataFrame 也是不可变的 Pandas Pandas 中 DataFrame 是可变的 创建 PySpark 直接创建： spark_df = sc.parallelize([(1, 2), (3, 4)]).toDF(['xx', 'yy'] 从 pandas_df 转换：spark_df = SQLContext.createDataFrame(pandas_df) 另外，createDataFrame 支持从 list 转换 spark_df，其中 list 元素可以为 tuple，dict，rdd 读取 CSV 文件：spark_df = spark.read.csv(csv_path, header=True) 如果 CSV 文件有 header，则将其读取为列名 读取 parquet 文件：spark_df = spark.read.parquet(parquet_path) 读取 json 文件：spark_df = spark.read.json(json_path) 读取 txt 文件：spark_df = sc.textFile(txt_path).toDF() 注：这些 path 均为 HDFS 路径 Pandas 直接创建： pandas_df = pd.DataFrame({'xx': {0: 1, 1: 3}, 'yy': {0: 2, 1: 4}}) 从 spark_df 转换：pandas_df = spark_df.toPandas()，或读取其他数据 读取 CSV 文件：pd.read_csv(csv_path) 读取 parquet 文件：pd.read_parquet(parquet_path)，其中如果 parquet_path 如果是 HDFS 路径则需要加前缀 'hdfs://'，比如：'hdfs:///projects/path/to/parquet/' 写入 PySpark 1df.repartition(partition_num).write.mode('overwrite'/'append').partitionBy(col_name).parquet(parquet_path) Pandas 1234df.to_csv(csv_path, index=True/False) # 是否保留indexdf.to_pickle(csv_pickle)df.to_parquet(parquet_path)df.to_csv(csv_path, index=True/False) index 索引 PySpark 没有 index 索引，若需要则要额外创建该列 12df.withColumn('index', F.row_number().over(Window.orderBy(F.monotonically_increasing_id())))df.rdd.zipWithIndex().toDF().select(F.col('_1').getItem('col_name_1').alias('col_name_1'), F.col('_2').getItem('col_name_2').alias('col_name_2'), ..., F.col('_n').getItem('col_name_n').alias('col_name_n'), F.col('_(n+1)').alias('row_index')) # 此方法更快 Pandas 自动创建 注：当将 pandas_df 转换为 spark_df 时如需保留索引，则可用 1spark_df = SQLContext.createDataFrame(pandas_df.reset_index()) 行结构 PySpark Row 结构，属于 Spark DataFrame 结构 Pandas Series 结构，属于 Pandas DataFrame 结构 列结构 PySpark Column 结构，属于 Spark DataFrame 结构，如：DataFrame[name: string] Pandas Series 结构，属于 Pandas DataFrame 结构 列名称 PySpark 允许重名，修改列名采用 alias 方法 修改列名：df.withColumnRenamed('old_name', 'new_name') df.select(F.col('old_name').alias('new_name'), ...) df.selectExpr('old_name as new_name', ...) Pandas 不允许重名 修改列名：df.rename(columns={'old_name': 'new_name'}) 列修改 PySpark 原来有 df['xx'] 列，df.withColumn('xx', 1) 如需判断逻辑：df.withColumn('xx', F.when(condition expression, true expression).otherwise(false expression)) 如需链接：df.withColumn('xx', F.concat(F.col('yy'), F.lit('-'), F.col('zz'))) 其中 yy 和 zz 列须为 string 类型，如不是则需要提前类型转换。 从文件路径取值：df.withColumn('xx', F.input_file_name().substr(start_index, stop_index)) Pandas 原来有 df['xx'] 列，df['xx'] = 1 如需判断逻辑：df.loc[condition expression, 'xx'] = true expression df.loc[~condition expression, 'xx'] = false expression df['xx'] = np.where(condition expression, true expression, false expression) df['xx'] = df.apply(lambda x: true expression if condition expression else false expression, axis=1) 如需链接：df['xx'] = df.yy + '-' + df.zz 其中 yy 和 zz 列须为 string 类型，如不是则需要提前类型转换。 显示 PySpark df 不输出具体内容，输出具体内容用 show 方法。df.show(5, truncate=100) 默认显示 20 行，每行显示长度通过 truncate 参数设置 以树的形式打印概要：df.printSchema() df.columns 输出列的名字 Pandas df 输出具体内容 df.columns 输出列的名字 pd.set_option('display.max_columns', None) # 显示所有列 pd.set_option('max_colwidth', 100) # 每行显示长度设置 pd.set_option('display.max_rows', None) # 显示所有行 排序 PySpark df.sort(df.xx.asc(),df.yy.desc()) df.sort(F.asc('xx'),F.desc('yy')) df.sort(F.col(\"xx\").asc(), F.col(\"yy\").desc()) df.orderBy(F.col(\"xx\").asc(), F.col(\"yy\").desc()) 在列中按值依次进行排序，指定先升序后降序 Pandas df.sort_index() 按轴进行升序排序 df.sort_values(['xx', 'yy'], ascending=[True, False]) 在列中按值依次进行排序，指定先升序后降序 df.sort_values(['xx', 'yy'], axis=0)，df.sort_values([1, 2], axis=1) 在列、行中按值进行升序排序 选择或切片 PySpark df.select('xx', 'yy') 选择一列或多列 df.first() 以行的形式返回第一行。（注：行的形式为 [Row(col_name1=value1, col_name2=value2, ...)]） df.head(n)，df.take(n) 以行的形式返回前 n 行；df.tail(n) 以行的形式返回最后 n 行 用 df.collect() 以行的形式返回所有行 Pandas df.xx，df['xx'] 选择列名为 xx 的列，df [k] 选择行名为 k 的行 df.iat[:, k]，df.iloc[:, k] 选择第 k 列，df.iat[k]，df.iloc[k] 选择第 k 行 过滤 PySpark df.filter(df['xx'] &gt; k) 或者 df.where(df['xx'] &gt; k) 取值存在于：df.filter(F.col('xx').isin(filter_list)) 空值处理： 值为 null：df.filter(F.col('xx').isNull()) 和 df.filter(F.col('xx').isNotNull()) 值为空字符串：df.filter(F.col('xx') == '') 值为 np.nan：df.filter(F.col('xx') == np.nan) Pandas df[df['xx']&gt;k] 或者 s[s&gt;k] 取值存在于：df[df.xx.isin(filter_list)] 空值处理：包括 null，np.NaN，pd.NaT，None，不包括空字符串 df[df.xx.isnull()] 或 df[df.xx.isna()] 和 df.filter(F.col('xx').notnull()) 或 df[df.xx.notnull()] 或 df[df.xx.notna()] Examples: 123456789101112131415&gt;&gt; pdf = pd.DataFrame(dict(numpy=[np.NaN], pandas=[pd.NaT], empty=[''], none=[None]))&gt;&gt; pdf numpy pandas empty none0 NaN NaT None&gt;&gt; pdf.isnull() numpy pandas empty none0 True True False True&gt;&gt; from pyspark.sql.types import *&gt;&gt; sdf = spark.createDataFrame(pdf, StructType([StructField('numpy', DoubleType(), True),StructField('pandas', StringType(), True),StructField('empty', StringType(), True),StructField('pandas', StringType(), True)])) # 必须指定schema，否则报错”ValueError: Some of types cannot be determined after inferring“&gt;&gt; sdf.show()+-----+------+-----+------+|numpy|pandas|empty|pandas|+-----+------+-----+------+| NaN| null| | null|+-----+------+-----+------+ 分组聚合 PySpark df.groupBy(cols_to_group) 或者 df.groupBy(cols_to_group).avg('xx').show() 应用单个函数 df.groupBy(cols_to_group).agg(F.avg('xx'), F.min('xx'), F.max('xx')).show() 应用多个函数 Pandas df.groupby(cols_to_group) df.groupby(cols_to_group).avg('xx') group filter by function: df.groupby(cols_to_group).filter(function) 统计 PySpark df.count() 输出总行数 df.describe() 描述某些列的 count, mean, stddev, min, max Pandas df.count() 输出每一列的非空行数 df.shape 输出行数 x 列数 df.describe() 描述某些列的 count, mean, std, min, 25%, 50%, 75%, max 合并 PySpark 扩充列 df.join() 同名列不自动添加后缀，只有键值完全匹配才保留一份副本 'inner', 'outer', 'full', 'fullouter', 'full_outer', 'leftouter', 'left', 'left_outer', 'rightouter', 'right', 'right_outer', 'leftsemi', 'left_semi', 'leftanti', 'left_anti', 'cross'. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&gt;&gt; df_left = spark.createDataFrame(pd.DataFrame({'Keys': ['key1', 'key2', 'key3', 'key4', 'key5'], 'Values_Left': ['value1', 'value2', 'value3', 'value4', 'value5']}, index=[0, 1, 2, 3, 4]))&gt;&gt; df_left.show()+----+-----------+|Keys|Values_Left|+----+-----------+|key1| value1||key2| value2||key3| value3||key4| value4||key5| value5|+----+-----------+&gt;&gt; df_right = spark.createDataFrame(pd.DataFrame({'Keys': ['key1', 'key2', 'key2', 'key3', 'key6'], 'Values_Right': ['value6', 'value7', 'value8', 'value9', 'value10']}, index=[0, 1, 2, 3, 4]))&gt;&gt; df_right.show()+----+------------+|Keys|Values_Right|+----+------------+|key1| value6||key2| value7||key2| value8||key3| value9||key6| value10|+----+------------+&gt;&gt; df_left.join(df_right, ['Keys'], 'left').sort('Keys').show() # left=leftouter=left_outer+----+-----------+------------+|Keys|Values_Left|Values_Right|+----+-----------+------------+|key1| value1| value6||key2| value2| value7||key2| value2| value8||key3| value3| value9||key4| value4| null||key5| value5| null|+----+-----------+------------+&gt;&gt; df_right.join(df_left, ['Keys'], 'right').sort('Keys').show() # right=rightouter=right_outer+----+------------+-----------+|Keys|Values_Right|Values_Left|+----+------------+-----------+|key1| value6| value1||key2| value7| value2||key2| value8| value2||key3| value9| value3||key4| null| value4||key5| null| value5|+----+------------+-----------+&gt;&gt; df_left.join(df_right, ['Keys'], 'left_semi').sort('Keys').show() # left_semi=leftsemi+----+-----------+|Keys|Values_Left|+----+-----------+|key1| value1||key2| value2||key3| value3|+----+-----------+&gt;&gt; df_left.join(df_right, ['Keys'], 'left_anti').sort('Keys').show() # leftanti=left_anti+----+-----------+|Keys|Values_Left|+----+-----------+|key4| value4||key5| value5|+----+-----------+&gt;&gt; df_left.join(df_right, ['Keys'], 'inner').sort('Keys').show()+----+-----------+------------+|Keys|Values_Left|Values_Right|+----+-----------+------------+|key1| value1| value6||key2| value2| value8||key2| value2| value7||key3| value3| value9|+----+-----------+------------+&gt;&gt; df_left.join(df_right, ['Keys'], 'outer').sort('Keys').show() # outer=full=fullouter=full_outer+----+-----------+------------+|Keys|Values_Left|Values_Right|+----+-----------+------------+|key1| value1| value6||key2| value2| value8||key2| value2| value7||key3| value3| value9||key4| value4| null||key5| value5| null||key6| null| value10|+----+-----------+------------+&gt;&gt; df_left = df_left.withColumnRenamed('Keys', 'Keys_Left')&gt;&gt; df_right = df_right.withColumnRenamed('Keys', 'Keys_Right')&gt;&gt; df_left.join(df_right, df_left.Keys_Left==df_right.Keys_Right, 'cross').show()+---------+-----------+----------+------------+|Keys_Left|Values_Left|Keys_Right|Values_Right|+---------+-----------+----------+------------+| key1| value1| key1| value6|| key2| value2| key2| value8|| key2| value2| key2| value7|| key3| value3| key3| value9|+---------+-----------+----------+------------+&gt;&gt; df_left.crossJoin(df_right).show(25)+---------+-----------+----------+------------+|Keys_Left|Values_Left|Keys_Right|Values_Right|+---------+-----------+----------+------------+| key1| value1| key1| value6|| key1| value1| key2| value7|| key1| value1| key2| value8|| key1| value1| key3| value9|| key1| value1| key6| value10|| key2| value2| key1| value6|| key2| value2| key2| value7|| key2| value2| key2| value8|| key2| value2| key3| value9|| key2| value2| key6| value10|| key3| value3| key1| value6|| key3| value3| key2| value7|| key3| value3| key2| value8|| key3| value3| key3| value9|| key3| value3| key6| value10|| key4| value4| key1| value6|| key4| value4| key2| value7|| key4| value4| key2| value8|| key4| value4| key3| value9|| key4| value4| key6| value10|| key5| value5| key1| value6|| key5| value5| key2| value7|| key5| value5| key2| value8|| key5| value5| key3| value9|| key5| value5| key6| value10|+---------+-----------+----------+------------+ 扩充行 df.union()：两个 df 合并，按位置进行合并，列名以前表为准（a.union (b) 列名顺序以 a 为准） df.unoinAll()：同 union 方法 df.unionByName()：两个 df 合并，按列名进行合并 df1.unionByName(df2).unionByName(df3) Pandas Pandas 下有 concat 方法，支持轴向合并 pd.concat([df1, df2, df3], ignore_index=True, sort=False) df1.append([df2, df3], ignore_index=True, sort=False) df1.join([df2, df3]) Pandas 下有 merge 方法，支持多列合并 同名列自动添加后缀，对应键仅保留一份副本 df.join() 支持多列合并 df.append() 支持多行合并 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&gt;&gt; df_left = pd.DataFrame({'Keys': ['key1', 'key2', 'key3', 'key4', 'key5'], 'Values_Left': ['value1', 'value2', 'value3', 'value4', 'value5']}, index=[0, 1, 2, 3, 4])&gt;&gt; df_right = pd.DataFrame({'Keys': ['key1', 'key2', 'key2', 'key3', 'key6'], 'Values_Right': ['value6', 'value7', 'value8', 'value9', 'value10']}, index=[0, 1, 2, 4, 5])&gt;&gt; df_left, df_right Keys Values_Left 0 key1 value1 1 key2 value2 2 key3 value3 3 key4 value4 4 key5 value5, Keys Values_Right 0 key1 value6 1 key2 value7 2 key2 value8 4 key3 value9 5 key6 value10&gt;&gt; df_left.append(df_right) &lt;=&gt; pd.concat([df_left, df_right])Keys Values_Left Values_Right0 key1 value1 NaN1 key2 value2 NaN2 key3 value3 NaN3 key4 value4 NaN4 key5 value5 NaN0 key1 NaN value61 key2 NaN value72 key2 NaN value84 key3 NaN value95 key6 NaN value10&gt;&gt; pd.concat([df_left, df_right], axis=1) # 类似join outer，key为index Keys Values_Left Keys Values_Right0 key1 value1 key1 value61 key2 value2 key2 value72 key3 value3 key2 value83 key4 value4 NaN NaN4 key5 value5 key3 value95 NaN NaN key6 value10&gt;&gt; pd.concat([df_left, df_right], axis=1, join='inner') Keys Values_Left Keys Values_Right0 key1 value1 key1 value61 key2 value2 key2 value72 key3 value3 key2 value84 key5 value5 key3 value9&gt;&gt; pd.merge(df_left, df_right, on='Keys') Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key2 value2 value83 key3 value3 value9&gt;&gt; pd.merge(df_left, df_right, how='left', on='Keys') Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key2 value2 value83 key3 value3 value94 key4 value4 NaN5 key5 value5 NaN&gt;&gt; pd.merge(df_left, df_right, how='right', on='Keys') Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key2 value2 value83 key3 value3 value94 key6 NaN value10&gt;&gt; pd.merge(df_left, df_right, how='outer', on='Keys', validate='one_to_many', indicator='indicator_column') Keys Values_Left Values_Right indicator_column0 key1 value1 value6 both1 key2 value2 value7 both2 key2 value2 value8 both3 key3 value3 value9 both4 key4 value4 NaN left_only5 key5 value5 NaN left_only6 key6 NaN value10 right_only&gt;&gt; pd.merge(df_left, df_right, how='inner', on='Keys') Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key2 value2 value83 key3 value3 value9&gt;&gt; df_left.join(df_right, how='left', lsuffix='_Left', rsuffix='_Right') Keys_Left Values_Left Keys_Right Values_Right0 key1 value1 key1 value61 key2 value2 key2 value72 key3 value3 key2 value83 key4 value4 NaN NaN4 key5 value5 key3 value9&gt;&gt; df_left.join(df_right, how='right', lsuffix='_Left', rsuffix='_Right') Keys_Left Values_Left Keys_Right Values_Right0 key1 value1 key1 value61 key2 value2 key2 value72 key3 value3 key2 value84 key5 value5 key3 value95 NaN NaN key6 value10&gt;&gt; df_left.join(df_right, how='outer', lsuffix='_Left', rsuffix='_Right') Keys_Left Values_Left Keys_Right Values_Right0 key1 value1 key1 value61 key2 value2 key2 value72 key3 value3 key2 value83 key4 value4 NaN NaN4 key5 value5 key3 value95 NaN NaN key6 value10&gt;&gt; df_left.join(df_right, how='inner', lsuffix='_Left', rsuffix='_Right') Keys_Left Values_Left Keys_Right Values_Right0 key1 value1 key1 value61 key2 value2 key2 value72 key3 value3 key2 value84 key5 value5 key3 value9&gt;&gt; df_left.join(df_right.reindex(['key1', 'key2', 'key2', 'key3', 'key6']), on='Keys', lsuffix='_Left', rsuffix='_Right') &lt;=&gt; pd.merge(df_left, df_right.reindex(['key1', 'key2', 'key2', 'key3', 'key6']), left_on=\"Keys\", right_index=True, how=\"left\", sort=False, suffixes=('_Left', '_Right')) Keys Keys_Left Values_Left Keys_Right Values_Right0 key1 key1 value1 NaN NaN1 key2 key2 value2 NaN NaN1 key2 key2 value2 NaN NaN2 key3 key3 value3 NaN NaN3 key4 key4 value4 NaN NaN4 key5 key5 value5 NaN NaN&gt;&gt; df_left.combine_first(df_right) # 相同Keys只保留左边的 Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key3 value3 value83 key4 value4 NaN4 key5 value5 value95 key6 NaN value10&gt;&gt; df_left.update(df_right)&gt;&gt; df_left Keys Values_Left0 key1 value11 key2 value22 key2 value33 key4 value44 key3 value5&gt;&gt; pd.merge_ordered(df_left, df_right, on=\"Keys\") Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key2 value2 value83 key2 value3 value74 key2 value3 value85 key3 value5 value96 key4 value4 NaN7 key6 NaN value10&gt;&gt; pd.merge_ordered(df_left, df_right, left_by=\"Keys\") Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key2 value2 value83 key2 value3 value74 key2 value3 value85 key4 value4 NaN6 key3 value5 value9&gt;&gt; pd.merge_ordered(df_left, df_right, right_by=\"Keys\") Keys Values_Left Values_Right0 key1 value1 value61 key2 value2 value72 key2 value2 value83 key2 value3 value74 key2 value3 value85 key3 value5 value96 key6 NaN value10&gt;&gt; df_left = df_left.rename(columns={'Values_Left': 'Values'})&gt;&gt; df_right = df_right.rename(columns={'Values_Right': 'Values'}).reset_index(drop=True)&gt;&gt; df_left.compare(df_right, align_axis=0) Keys Values0 self NaN value1 other NaN value61 self NaN value2 other NaN value72 self NaN value3 other NaN value83 self key4 value4 other key3 value94 self key3 value5 other key6 value10&gt;&gt; df_left.compare(df_right, keep_shape=True) Keys Values self other self other0 NaN NaN value1 value61 NaN NaN value2 value72 NaN NaN value3 value83 key4 key3 value4 value94 key3 key6 value5 value10&gt;&gt; df_left.compare(df_right, keep_shape=True, keep_equal=True) Keys Values self other self other0 key1 key1 value1 value61 key2 key2 value2 value72 key2 key2 value3 value83 key4 key3 value4 value94 key3 key6 value5 value10 删除 PySpark 删除一列：df.drop('xx') 或者 df.drop(F.col('xx')) 删除多列：df.drop(*['xx', 'yy', ...]) 删除某（些）行：使用 filter 方法 去重：df.dropDuplicates() 或 df.drop_duplicates() 其中参数必须为数组，df.distinct() 其中不能传入参数。 在 cols_to_group 相同的情况下保留 xx 列的值最小 / 最大的行： 123456789101112131415161718192021222324252627282930313233df.groupBy(cols_to_group).agg(F.min/max('xx').alias('xx'))df.withColumn('min/max', F.min/max('xx').over(Window.partitionBy(cols_to_group))).where(F.col('xx') == F.col('min/max'))# example&gt;&gt; pdf = pd.DataFrame(dict(os=['ANDROID', 'ANDROID', 'IOS', 'IOS', 'IOS', 'IOS'], region=['SG', 'SG', 'SG', 'SG', 'CN', 'CN'], value=[1,2,3,4,5,6]))&gt;&gt; sdf = spark.createDataFrame(pdf)&gt;&gt; sdf.show()+-------+------+-----+| os|region|value|+-------+------+-----+|ANDROID| SG| 1||ANDROID| SG| 2|| IOS| SG| 3|| IOS| SG| 4|| IOS| CN| 5|| IOS| CN| 6|+-------+------+-----+&gt;&gt; sdf.groupBy(['os', 'region']).agg(F.min('value')).show()+-------+------+----------+| os|region|min(value)|+-------+------+----------+| IOS| CN| 5|| IOS| SG| 3||ANDROID| SG| 1|+-------+------+----------+&gt;&gt; from pyspark.sql.window import Window&gt;&gt; sdf.withColumn('min', F.min('value').over(Window.partitionBy(['os', 'region']))).where(F.col('value') == F.col('min')).show()+-------+------+-----+---+| os|region|value|min|+-------+------+-----+---+| IOS| CN| 5| 5|| IOS| SG| 3| 3||ANDROID| SG| 1| 1|+-------+------+-----+---+ Pandas 删除某（些）列：df.drop(['xx', 'xx'], axis=1) 或者 df.drop(columns=['xx', 'yy']) 删除某（些）行：df.drop([0, 1]) 其中 0，1 为 index 名字 去重：drop_duplicates(subset=None, keep='first', inplace=False, ignore_index=False) 其中 keep 取值 {‘first’, ‘last’, False}；keep 第一次或者最后一次出现。如果需要根据某列最大最小值保留的话，则需提前排序 更改数据类型 PySpark 更改指定列的数据类型：df = df.withColumn('xx', F.col('xx').cast(Type())) Pandas 更改所有列的数据类型：df.astype('type') 更改指定列的数据类型：df.astype({'xx': 'int32'}) 失数据处理 PySpark 不自动添加 NaNs，且不抛出错误 fillna 函数：df.na.fill() dropna 函数：df.na.drop() Pandas 对缺失数据自动添加 NaNs fillna 函数：df.fillna() dropna 函数：df.dropna() SQL 语句 PySpark 表格注册：把 DataFrame 结构注册成 SQL 语句使用类型 df.registerTempTable('tt') 或者 sqlContext.registerDataFrameAsTable(df, 'tt') spark.sql('SELECT xx, yy FROM tt WHERE xx &gt;= m AND yy &lt;= n') 功能注册：把函数注册成 SQL 语句使用类型 spark.registerFunction('stringLengthString', lambda x: len(x)) spark.sql(\"SELECT stringLengthString('test')\") Pandas import sqlite3 pd.read_sql('SELECT xx, yy FROM tt WHERE xx &gt;= m AND yy &lt;= n') 两者互相转换 PySpark pandas_df = spark_df.toPandas() ArrayType(), StructType(), MapType() 类型需要提前转换成 string，pandas 不支持 Pandas spark_df = spark.createDataFrame(pandas_df) 转换过程中可能会遇到报错： TypeError: field xx: Can not merge type A and B 原因是该列存在空值。解决方法是转换成 String pandas_df.xx = pandas_df.xx.astype(str) 函数应用 PySpark df.foreach(f) 或者 df.rdd.foreach(f) 将 df 的每一列应用函数 f df.foreachPartition(f) 或者 df.rdd.foreachPartition(f) 将 df 的每一块应用函数 f UDF (User-defined Function): 12345678910# one-line way:udf_name = F.udf(lambda x, y: expression, ReturnType())# def way:@F.udf(returnType=ReturnType())def udf_name(x): expression returndf.withColumn('xx', udf_name(F.col('xx'), F.col('yy'))) Pandas df.apply(f) 将 df 的每一列应用函数 f Pandas udf in PySpark Driver 可能缺少必要的 package:pyarrow 导致报错 ModuleNotFoundError: No module named 'pyarrow'。有多种方案解决： 参考 Python Package Management PySpark 允许通过以下方式将 Python 文件 (.py)、压缩的 Python 包 (.zip) 和 Egg 文件 (.egg) 上传到执行程序： 设置配置 spark.submit.pyFiles 或者 --py-filesSpark 脚本中的设置选项或者直接调用 pyspark.SparkContext.addPyFile()应用程序。 这是将额外的自定义 Python 代码发送到集群的直接方法。只添加单个文件或压缩整个包并上传它们。如果使用 pyspark.SparkContext.addPyFile()，即使 job 开始运行后也允许使用上传的代码。 但是不允许添加构建为 Wheels 包，因此不允许包含与本机代码的依赖关系。 使用 Conda 打包 Conda 是使用最广泛的 Python 包管理系统之一。PySpark 可以直接使用 Conda 环境通过利用 conda-pack 来传送第三方 Python 包，它是一个命令行工具，可创建可重定位的 Conda 环境。 下面的示例创建了一个 Conda 环境以在驱动程序和执行程序上使用，并将其打包到一个存档文件中。此存档文件捕获 Python 的 Conda 环境并存储 Python 解释器及其所有相关依赖项。 123conda create -y -n pyspark_conda_env -c conda-forge pyarrow pandas conda-packconda activate pyspark_conda_envconda pack -f -o pyspark_conda_env.tar.gz 之后可以使用 --archives 选项或 spark.archives 配置（spark.yarn.dist.archives 在 YARN 中）将其与脚本或代码一起发送。它会自动解压缩执行程序上的存档。 在 spark-submit 脚本的情况下，您可以按如下方式使用它： 123export PYSPARK_DRIVER_PYTHON=python # Do not set in cluster modes.export PYSPARK_PYTHON=./environment/bin/pythonspark-submit --archives pyspark_conda_env.tar.gz#environment app.py 注意 PYSPARK_DRIVER_PYTHON 不应为 YARN 集群模式设置上述内容。 如果您使用的是常规 Python shell 或 Notebook，您可以尝试如下所示： 1234567891011121314151617181920import osfrom pyspark.sql import SparkSessionfrom app import mainos.environ['PYSPARK_PYTHON'] = './environment/bin/python'os.environ['PYSPARK_DRIVER_PYTHON'] = './environment/bin/python'spark = SparkSession.builder.config( \"spark.archives\", # 'spark.yarn.dist.archives' in YARN. \"pyspark_conda_env.tar.gz#environment\").getOrCreate()main(spark)# 或者SPARK_CONF = SparkConf() \\ .set('spark.yarn.dist.archives', 'pyspark_conda_env.tar.gz#environment') \\ .set('spark.yarn.appMasterEnv.ARROW_PRE_0_15_IPC_FORMAT', '1') \\ .set('spark.executorEnv.ARROW_PRE_0_15_IPC_FORMAT', '1')sc = SparkContext(appName=appName, conf=SPARK_CONF)sc.setLogLevel('ERROR')spark = SparkSession.builder.enableHiveSupport().getOrCreate() 对于 pyspark Shell： 123export PYSPARK_DRIVER_PYTHON=pythonexport PYSPARK_PYTHON=./environment/bin/pythonpyspark --archives pyspark_conda_env.tar.gz#environment 使用本机，不用集群 123456SPARK_CONF = SparkConf() \\ .setMaster('local') \\ .set('spark.submit.deployMode', 'client') sc = SparkContext(appName=appName, conf=SPARK_CONF) sc.setLogLevel('ERROR') spark = SparkSession.builder.enableHiveSupport().getOrCreate() Map-Reduce 操作 PySpark df.map(func)，df.reduce(func) 返回类型 seqRDDs Pandas map-reduce操作map(func, list)，reduce(func, list) 返回类型 seq Diff 操作 PySpark 没有 diff 操作（Spark 的上下行是相互独立，分布式存储的） Pandas 有 diff 操作，处理时间序列数据（Pandas 会对比当前行与上一行） Most Common 计数 PySpark 12df.cube(column_name/column_list).count().sort('count', ascending=False)df.groupBy(column_name/column_list).agg({'*': 'count'}).withColumnRenamed('count(1)', 'new_count') Pandas df.value_counts(ascending=False) Json 格式化、选择、解析 PySpark 格式化：df.withColum('json_string', F.to_json(F.struct('key1', 'key2'))) 选择：df.select('json_string.key') 解析：json_schema = spark.read.json(df.rdd.map(lambda row: row.json_string)).schema F.get_json_object('json_string', '$.key') F.from_json(F.get_json_object('json_string', '$.key'), schema) Pandas 格式化：df['json_string'] = df[['key1', 'key2']].to_dict(orient='records') 选择：df.json_string.apply(pd.Series).key 解析： 1df.join(pd.concat(list(df['json_string'].apply(lambda x: pd.json_normalize(json.loads(x)))), ignore_index=True)) Explode 操作、Pivot 操作、Melt 操作 PySpark Explode &lt;=&gt; Groupby： 将 xx 列中的每行的列表 / 数组值分拆形成单独的行 1234df.withColumn('xx', explode(F.col('yy'))) # 忽略空值或者空列表/数组df.withColumn('xx', explode_outer(F.col('yy'))) # 不忽略空值或者空列表/数组df.groupBy(cols_to_group).agg(F.collect_list('xx').alias('yy')) # 返回list形式，不去重df.groupBy(cols_to_group).agg(F.collect_set('xx').alias('yy')) # 返回set形式，去重 Pivot &lt;=&gt; Melt Label Keys Values 0 'key1' 'value1' 0 'key2' 'value2' 1 'key1' 'value3' 1 'key2' 'value4' &lt;=&gt; Label key1 key2 0 'value1' 'value2' 1 'value3' 'value4' 12345678def melt(df, id_vars, value_vars, var_name, value_name): _vars_and_vals = F.create_map(list(chain.from_iterable([[F.lit(c), F.col(c)] for c in value_vars]))) _tmp = df.select(*id_vars, explode(_vars_and_vals)).withColumnRenamed('key', var_name).withColumnRenamed('value', value_name) return _tmp.select(*cols)df_melt = df.selectExpr('Label', 'stack({}, {}) as (Keys, Values)'.format(len(cols), ', '.join((\"'{}', {}\".format(i, i) for i in df.columns[1:])))).where(F.col('Values').isNotNull())df_melt = melt(df, id_vars='Label', value_vars=df.columns[1:], var_name='Keys', value_name='Values')df_pivot = df_melt.groupBy('Label').pivot('Keys').agg(F.first('Values')) Pandas Explode： 12345678910111213141516171819202122232425262728&gt;&gt; df = pd.DataFrame( {'a':['A', 'B', 'C'], 'b':[[1], [2, 3], [4, 5, 4]]})&gt;&gt; df.explode('b') # explode的列名还是b a b0 A 11 B 21 B 32 C 42 C 52 C 4&gt;&gt; df = pd.DataFrame( {'a':['A', 'B', 'B', 'C', 'C', 'C'], 'b':[1, 2, 3, 4, 5, 4]})&gt;&gt; df a b0 A 11 B 22 B 33 C 44 C 55 C 4&gt;&gt; df.groupby('a')['b'].apply(list).reset_index() a b0 A [1]1 B [2, 3]2 C [4, 5, 4]&gt;&gt; df.groupby('a')['b'].apply(set).apply(list).reset_index() a b0 A [1]1 B [2, 3]2 C [4, 5] Pivot &lt;=&gt; Melt： Label Keys Values 0 'key1' 'value1' 0 'key2' 'value2' 1 'key1' 'value3' 1 'key2' 'value4' &lt;=&gt; Values Keys key1 key2 Label 0 value1 value2 1 value3 value4 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt; import numpy as np&gt;&gt; import pandas as pd&gt;&gt; def melt(frame):&gt;&gt; # identifier is index&gt;&gt; N, K = frame.shape&gt;&gt; data = {&gt;&gt; \"Values\": frame.to_numpy().ravel(),&gt;&gt; \"Keys\": np.tile(np.asarray(frame.columns), K),&gt;&gt; \"Label\": np.asarray(frame.index).repeat(N),&gt;&gt; }&gt;&gt; return pd.DataFrame(data, columns=[\"Label\", \"Keys\", \"Values\"])&gt;&gt; df = pd.DataFrame({'key1': ['value1', 'value3'], 'key2': ['value2', 'value4']}, index=[0, 1]) key1 key20 value1 value21 value3 value4&gt;&gt; df_melt = melt(df) Label Keys Values0 0 key1 value11 0 key2 value22 1 key1 value33 1 key2 value4&gt;&gt; df = df.reset_index().rename(columns={'index': 'Label'}) Label key1 key20 0 value1 value21 1 value3 value4&gt;&gt; df_melt = df.melt(id_vars=['Label'], var_name='Keys', value_name='Values').sort_values('Label').reset_index(drop=True) Label Keys Values0 0 key1 value11 0 key2 value22 1 key1 value33 1 key2 value4&gt;&gt; df_pivot = df_melt.pivot(index=\"Label\", columns=\"Keys\", values=\"Values\")Keys key1 key2Label 0 value1 value21 value3 value4","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Data Analysis","slug":"Data-Analysis","permalink":"https://lxmymjr.github.io/tags/Data-Analysis/"}]},{"title":"Linux 实用工具","slug":"Linux-实用工具","date":"2020-09-28T08:18:44.000Z","updated":"2021-09-16T02:56:10.894Z","comments":true,"path":"contents/Linux-实用工具.html","link":"","permalink":"https://lxmymjr.github.io/contents/Linux-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7.html","excerpt":"Linux 的终端上有很多实用小工具，能提高工作效率，比如 tmux。 在此介绍他们的用法、配置和快捷键。","text":"Linux 的终端上有很多实用小工具，能提高工作效率，比如 tmux。 在此介绍他们的用法、配置和快捷键。 TMUX 参考资料：一文助你打通 tmux，Tmux 使用教程 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称 \"窗口\"），窗口可以被不断切割，切割成一个个小块，这一个个小块我们叫做窗格（pane）。在里面输入命令。用户与计算机的这种临时的交互，称为一次 \"会话\"（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 Tmux 就是会话与窗口的 \"解绑\" 工具，将它们彻底分离：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话 \"绑定\" 其他窗口。 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 它可以让新窗口 \"接入\" 已经存在的会话。 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 它还支持窗口任意的垂直和水平拆分。 tmux 的安装 Linux 系统中通常使用 yum 来安装 tmux : yum install tmux Mac OS 系统中通常使用 brew 来安装 tmux :brew install tmux tmux 的前缀键 tmux 中的很多操作都是通过快捷键来实现的，通过快捷键我们可以更加高效的完成任务。如果想使用 tmux 中的快捷键，我们必须使用 tmux 的前缀按键 ctrl + b , 在 tmux 中所有的快捷键都需要通过前缀按键去唤起的。 tmux 的会话常用操作 操作 命令 快捷键 新建会话 tmux / tmux new -s &lt;session-name&gt; 无 离开会话 tmux detach (ctrl + b) d 查看会话列表 tmux ls (ctrl + b) s 进入会话 ta/tmux attach -t &lt;session-name&gt; 无 关闭会话 tmux kill-session -t &lt;session-name&gt; ctrl + d 切换会话 tmux switch -t &lt;session-name&gt; 无 重命名会话 tmux rename-session -t &lt;old-session-name&gt; &lt;new-session-name&gt; (ctrl +b) $ tmux 的窗格常用操作 操作 命令 快捷键 水平分割窗格 tmux split-window -h（左右） (ctrl + b) %（左右） 垂直分割窗格 tmux split-window （上下） (ctrl + b) “（上下） 光标移动到上方窗格 tmux select-pane -U (ctrl +b) ↑ 光标移动到下方窗格 tmux select-pane -D (ctrl +b) ↓ 光标移动到左边窗格 tmux select-pane -L (ctrl +b) ← 光标移动到右边窗格 tmux select-pane -R (ctrl +b) → 光标切换到上一个窗格 无 (ctrl +b) ; 光标切换到下一个窗格 无 (ctrl +b) o 当前窗格向上移动 tmux swap-pane -U 无 当前窗格向下移动 tmux swap-pane -D 无 关闭当前的窗格 无 (ctrl +b) x 最大化窗格 无 (ctrl +b) z 触发两次还原当前的窗格大小 显示时间 无 (ctrl +b) t 点击 Enter 将会复原 tmux 的窗口常用操作 操作 命令 快捷键 创建窗口 tmux new-window -n &lt;window-name&gt; (ctrl + b) c 切换窗口 tmux select-window -t &lt;window-name&gt; (ctrl +b) w 显示窗口列表可以通过 j,k 上下进行选择窗口，然后回车进入指定的窗口。(ctrl +b) n 快速切换到下一个窗口。(ctrl +b) p 快速切换到上一个窗口。 重命名窗口 tmux rename-window &lt;new-window-name&gt; (ctrl +b) , 关闭窗口 tmux kill-window -t &lt;window-name&gt; (ctrl +b) &amp; tmux 的配置 .tmux.conf 默认放在 ～（home 目录） 目录下面，以下是本人配置： 1234567891011121314151617181920212223set -g mode-keys viset -g default-shell /bin/zshset -g @plugin 'tmux-plugins/tpm'set -g @plugin 'tmux-plugins/tmux-sensible'set -g @plugin 'tmux-plugins/tmux-yank'set -g @plugin 'fcsonline/tmux-thumbs'set -g @plugin 'schasse/tmux-jump'set -g @plugin 'dracula/tmux'if '[ -f ~/dotfiles/tmux/bindings.tmux ]' 'source ~/dotfiles/tmux/bindings.tmux'# 主题配置set -g @dracula-show-battery falseset -g @dracula-show-network falseset -g @dracula-show-weather falseset -g @dracula-show-timezone falseset -g @dracula-military-time trueset -g @dracula-border-contrast trueset -g @dracula-cpu-usage trueset -g @dracula-ram-usage trrun '~/.tmux/plugins/tpm/tpm' tmux-plugins/tpm 是 Tmux Plugin Manager，即 Tmux 的插件管理工具。 tmux-plugins/tmux-sensible，一组人人都能接受的选项。 tmux-plugins/tmux-yank，允许拷贝至系统剪切板。 schasse/tmux-jump，按 tmux-prefix+j 键进入 jump 模式，输入需要跳转到的位置的字符，屏幕会高亮显示符合条件的位置并分配一个 key，输入 key 后光标就会跳转至选中位置。 dracula 主题。 在 Tmux 中，安装插件的一些快捷命令如下: 123prefix shift-i # installprefix shift-u # updateprefix alt-u # uninstall plugins not on the plugin list bindings.tmux 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134# -- general -------------------------------------------------------------------set -g default-terminal \"screen-256color\" # colors!setw -g xterm-keys onset -s escape-time 10 # faster command sequencesset -sg repeat-time 300 # increase repeat timeoutset -s focus-events onset -g prefix2 C-a # GNU-Screen compatible prefixbind C-a send-prefix -2set -q -g status-utf8 on # expect UTF-8 (tmux &lt; 2.2)setw -q -g utf8 onset -g history-limit 5000 # boost history# edit configuration# bind e new-window -n \"~/.tmux.conf.local\" \"sh -c '\\${EDITOR:-vim} ~/.tmux.conf.local &amp;&amp; tmux source ~/.tmux.conf &amp;&amp; tmux display \\\"~/.tmux.conf sourced\\\"'\"bind E command-prompt -p \"Command:\" \\ \"run \\\"tmux list-panes -a -F '##{session_name}:##{window_index}.##{pane_index}' \\ | xargs -I PANE tmux send-keys -t PANE '%1' Enter\\\"\"# reload configurationbind r source-file ~/.tmux.conf \\; display '~/.tmux.conf sourced'# send the prefix to client inside windowbind-key -n C-q send-prefix# -- display -------------------------------------------------------------------set -g base-index 1 # start windows numbering at 1setw -g pane-base-index 1 # make pane numbering consistent with windowssetw -g automatic-rename on # rename window to reflect current programset -g renumber-windows on # renumber windows when a window is closedset -g set-titles on # set terminal title# fix the window nameset-option -g allow-rename offset -g display-panes-time 800 # slightly longer pane indicators display timeset -g display-time 1000 # slightly longer status messages display timeset -g status-interval 10 # redraw status line every 10 seconds# clear both screen and historybind -n C-l send-keys C-l \\; run 'sleep 0.1' \\; clear-history# activityset -g monitor-activity onset -g visual-activity off# -- navigation ----------------------------------------------------------------# create sessionbind C-c new-session# find sessionbind C-f command-prompt -p find-session 'switch-client -t %%'# split current window horizontallybind - split-window -v -c \"#{pane_current_path}\"# split current window verticallybind _ split-window -h -c \"#{pane_current_path}\"bind | split-window -h -c \"#{pane_current_path}\"bind c new-window -c \"#{pane_current_path}\"# pane navigationbind -r h select-pane -L # move leftbind -r j select-pane -D # move downbind -r k select-pane -U # move upbind -r l select-pane -R # move rightbind -r &gt; swap-pane -D # swap current pane with the next onebind -r &lt; swap-pane -U # swap current pane with the previous one# pane resizingbind -r H resize-pane -L 2bind -r J resize-pane -D 2bind -r K resize-pane -U 2bind -r L resize-pane -R 2# window navigationunbind nunbind pbind -r C-h previous-window # select previous windowbind -r C-l next-window # select next windowbind Tab last-window # move to last active window# kill panebind -r W kill-panebind C-w kill-pane# -- copy mode -----------------------------------------------------------------bind Enter copy-mode # enter copy moderun -b 'tmux bind -t vi-copy v begin-selection 2&gt; /dev/null || true'run -b 'tmux bind -T copy-mode-vi v send -X begin-selection 2&gt; /dev/null || true'run -b 'tmux bind -t vi-copy C-v rectangle-toggle 2&gt; /dev/null || true'run -b 'tmux bind -T copy-mode-vi C-v send -X rectangle-toggle 2&gt; /dev/null || true'run -b 'tmux bind -t vi-copy y copy-selection 2&gt; /dev/null || true'run -b 'tmux bind -T copy-mode-vi y send -X copy-selection-and-cancel 2&gt; /dev/null || true'run -b 'tmux bind -t vi-copy Escape cancel 2&gt; /dev/null || true'run -b 'tmux bind -T copy-mode-vi Escape send -X cancel 2&gt; /dev/null || true'run -b 'tmux bind -t vi-copy H start-of-line 2&gt; /dev/null || true'run -b 'tmux bind -T copy-mode-vi H send -X start-of-line 2&gt; /dev/null || true'run -b 'tmux bind -t vi-copy L end-of-line 2&gt; /dev/null || true'run -b 'tmux bind -T copy-mode-vi L send -X end-of-line 2&gt; /dev/null || true'# copy to macOS clipboardif -b 'command -v pbcopy &gt; /dev/null 2&gt;&amp;1' 'bind y run -b \"tmux save-buffer - | pbcopy\"'if -b 'command -v reattach-to-user-namespace &gt; /dev/null 2&gt;&amp;1' 'bind y run -b \"tmux save-buffer - | reattach-to-user-namespace pbcopy\"'# copy to X11 clipboardif -b 'command -v xsel &gt; /dev/null 2&gt;&amp;1' 'bind y run -b \"tmux save-buffer - | xsel -i -b\"'if -b '! command -v xsel &gt; /dev/null 2&gt;&amp;1 &amp;&amp; command -v xclip &gt; /dev/null 2&gt;&amp;1' 'bind y run -b \"tmux save-buffer - | xclip -i -selection clipboard &gt;/dev/null 2&gt;&amp;1\"'# copy to Windows clipboardif -b 'command -v clip.exe &gt; /dev/null 2&gt;&amp;1' 'bind y run -b \"tmux save-buffer - | clip.exe\"'if -b '[ -c /dev/clipboard ]' 'bind y run -b \"tmux save-buffer - &gt; /dev/clipboard\"'# -- buffers -------------------------------------------------------------------bind b list-buffers # list paste buffersbind p paste-buffer # paste from the top paste bufferbind P choose-buffer # choose which buffer to paste from# -- mouse mode ----------------------------------------------------------------set -g mouse on# Toggle mouse onbind-key M \\ set-option -g mouse on \\;\\ display-message 'Mouse: ON'# Toggle mouse offbind-key m \\ set-option -g mouse off \\;\\ display-message 'Mouse: OFF'","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/categories/Tutorial/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"}]},{"title":"解锁网易云音乐客户端变灰歌曲","slug":"解锁网易云音乐客户端变灰歌曲","date":"2019-06-20T14:50:16.000Z","updated":"2021-09-16T02:56:10.897Z","comments":true,"path":"contents/解锁网易云音乐客户端变灰歌曲.html","link":"","permalink":"https://lxmymjr.github.io/contents/%E8%A7%A3%E9%94%81%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%98%E7%81%B0%E6%AD%8C%E6%9B%B2.html","excerpt":"网易云音乐现如今很多音乐涉及到版权的问题无法播放，即使开了 VIP 也不行。 下面介绍一个开源项目，来解决这个问题！亲测有效！推荐大家本机部署！","text":"网易云音乐现如今很多音乐涉及到版权的问题无法播放，即使开了 VIP 也不行。 下面介绍一个开源项目，来解决这个问题！亲测有效！推荐大家本机部署！ 项目地址 解锁网易云音乐客户端变灰歌曲 github 参考教程 功能特点 使用网易云旧链 / QQ / 虾米 / 百度 / 酷狗 / 酷我 / 咕咪 / JOOX 音源替换变灰歌曲链接 (默认仅启用前四)。 为请求增加 X-Real-IP 参数解锁海外限制，支持指定网易云服务器 IP，支持设置上游 HTTP / HTTPS 代理。 完整的流量代理功能 (HTTP / HTTPS)，可直接作为系统代理 (同时支持 PAC)。 Windows 安装 下载安装 Node.js。 下载项目源码到本地，并解压到 / UnblockNeteaseMusic 目录。 以管理员身份运行 CMD，切换到 / UnblockNeteaseMusic 目录，然后安装依赖库 npm install 打开网易客户端，点击右上角【设置】 – 【工具】 – 【Http 代理】 – 点击【自定义代理】 – 下拉框选择【HTTP 代理】，输入服务器地址 127.0.0.1 和端口 18080，重启客户端。 使用 打开命令行，切换到 / UnblockNeteaseMusic 目录，输入 node app.js –p 18080，然后再打开网易云音乐客户端即可。","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/categories/Tutorial/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"}]},{"title":"主流视频网站弹幕下载","slug":"主流视频网站弹幕下载","date":"2019-04-08T08:41:10.000Z","updated":"2021-09-16T02:56:10.896Z","comments":true,"path":"contents/主流视频网站弹幕下载.html","link":"","permalink":"https://lxmymjr.github.io/contents/%E4%B8%BB%E6%B5%81%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99%E5%BC%B9%E5%B9%95%E4%B8%8B%E8%BD%BD.html","excerpt":"如今主流的视频网站（如 bilibili，腾讯，爱奇艺，优酷，芒果 TV 等）都支持了弹幕，本文介绍了如何下载视频弹幕（.xml）文件并转化为字幕（.ass）文件，支持本地播放。","text":"如今主流的视频网站（如 bilibili，腾讯，爱奇艺，优酷，芒果 TV 等）都支持了弹幕，本文介绍了如何下载视频弹幕（.xml）文件并转化为字幕（.ass）文件，支持本地播放。 XML 格式弹幕 B 站是最早的一批弹幕网站之一，且比较成熟，弹幕可以直接以 XML 格式下载，非常方便，所以本文下载的弹幕均以 B 站的 XML 弹幕格式的简化为标准格式。 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;i&gt; &lt;d p=\"5,1,20,16777215\"&gt;这是一条弹幕&lt;/d&gt; ...&lt;/i&gt; 每一条弹幕的属性 p 的格式为： 弹幕发送时间，相对于视频开始时间，以秒为单位 弹幕类型，1-3 为滚动弹幕、4 为底部、5 为顶端、6 为逆向、7 为精确、8 为高级 字体大小，25 为中，18 为小，Bilibili 只有这 2 个字号，本地 20 字号比较合适（电脑分辨率是 1920*1080） 弹幕颜色，RGB 颜色转为十进制后的值，16777215 为白色 弹幕发送时间，Unix 时间戳格式 弹幕池，0 为普通，1 为字幕，2 为特殊 发送人的 id 弹幕 id 一般只需要使用前 4 项即可。 Python 中利用 request 库来爬取网页结果： 1234567import urllib.requestdef get_response(url): req = urllib.request.Request(url) req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = urllib.request.urlopen(req).read().decode('utf-8') return response 生成 XML 弹幕文件时需要检查是否有非法 XML 字符，并可以设置弹幕黑名单： 1234567891011121314151617filename = 'XML/' + title + '.xml'contents = []with open(filename, 'w', encoding='utf-8') as fout: fout.write('&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n') fout.write('&lt;i&gt;\\n') illegal = False #标志是否有非法XML字符 for char in ['&lt;', '&gt;', '&amp;', '\\u0000', '\\b']: if char in j['content']: illegal = True break if illegal: continue black_list = [''] #列出弹幕黑名单 if content not in contents and all(word not in content for word in black_list): contents.append(content) fout.write('&lt;d p=\"' + str(timepoint) + ',' + str(ct) +',' + str(size) + ',' + str(color) + '\"&gt;' + content + '&lt;/d&gt;\\n') fout.write('&lt;/i&gt;') 网上很多相关工具（如弹幕 ASS 转换工具等）可以将 XML 弹幕文件转换成 ASS 字幕文件。 基于弹幕 ASS 转换工具个性化设置： 123456789101112131415161718192021// 设置项，适合视频2倍速播放var config = { 'playResX': 1440, // 屏幕分辨率宽（像素） 'playResY': 810, // 屏幕分辨率高（像素） 'fontlist': [ // 字形（会自动选择最前面一个可用的） '黑体', 'Microsoft YaHei UI', 'Microsoft YaHei', '文泉驿正黑', 'STHeitiSC', ], 'font_size': 1.2, // 字号（比例） 'r2ltime': 20, // 右到左弹幕持续时间（秒） 'fixtime': 5, // 固定弹幕持续时间（秒） 'opacity': 0.8, // 不透明度（比例） 'space': 0, // 弹幕间隔的最小水平距离（像素） 'max_delay': 6, // 最多允许延迟几秒出现弹幕 'bottom': 0, // 底端给字幕保留的空间（像素） 'use_canvas': true, // 是否使用canvas计算文本宽度（布尔值，Linux下的火狐默认否，其他默认是，Firefox bug #561361） 'debug': false, // 打印调试信息}; 腾讯视频弹幕下载 打开一个腾讯视频 PC 网页端，其源码中的 VIDEO_INFO 字段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var VIDEO_INFO = { \"publish_date\": \"\", \"leading_actor_id\": [\"\"], \"duration\": , \"guests\": , \"race_teams_id\": , \"type_name\": , \"tag\": [ ], \"singer_id\": , \"episode\": , \"race_stars_id\": , \"srcsite_name\": , \"type\": , \"title\": , \"leading_actor\": [\"\"], \"show_type\": , \"singer_name\": , \"danmu_status\": , \"second_title\": , \"positive_trailer\": , \"athlete\": , \"mv_stars\": , \"trytime_second\": , \"c_full\": , \"update_flag\": , \"first_recommand\": , \"desc\": , \"pioneer_tag\": , \"begin_time\": , \"upload_qq\": , \"category_map\": [, \"\"], \"is_trailer\": , \"stars_name\": , \"pic_640_360\": , \"c_title_segment\": , \"guests_id\": , \"presenter_id\": , \"upload_src\": , \"athlete_id\": , \"sec_recommand\": , \"costar_id\": , \"relative_stars_id\": , \"relative_stars\": , \"drm\": , \"modify_time\": , \"tail_time\": , \"valid_tag_id\": , \"vid\": , \"pic_url\": , \"costar\": , \"race_teams_name\": , \"c_title_output\": , \"director_id\": [\"\"], \"title_en\": , \"stars\": , \"danmu\": , \"mv_stars_id\": , \"playright\": [\"\"], \"presenter\": , \"race_stars\": , \"view_all_count\": , \"c_tags_flag\": , \"c_has_adv_danmu\": , \"head_time\": , \"state\": , \"copyright_id\": , \"pic160x90\": , \"director\": [\"\"], \"famous_id\": , \"pioneer_tag_ids\": , \"trytime\": , \"famous_actor\": , \"video_checkup_time\": , \"\": , \"isFull\": }; 其中所需的字段是duration、title、vid。 接下来通过vid找到targetid：http://bullet.video.qq.com/fcgi-bin/target/regist?otype=json&amp;vid=(%vid%)，打开此链接得到： 1234567891011QZOutputJson = { \"danmukey\":\"bubble_flag=&amp;targetid=&amp;vid=&amp;type=\", \"display\":, \"is_has_adv\":, \"is_has_bubble\":, \"open\":, \"returncode\":, \"returnmsg\":, \"targetid\":, \"userstatus\":} 然后就可以通过targetid得到弹幕：http://mfm.video.qq.com/danmu?timestamp=(%timestamp%)&amp;target_id=(%targetid%)，其中timestamp从0开始并且以30为增量，打开此链接得到（只截取了第一条弹幕）： 123456789101112131415161718192021222324252627282930{ \"err_code\":, \"err_msg\":, \"peroid\":, \"target_id\":, \"count\":, \"tol_up\":, \"single_max_count\":, \"session_key\":, \"comments\":[ { \"commentid\":, \"content\":, \"upcount\":, \"isfriend\":, \"isop\":, \"isself\":, \"timepoint\":, \"headurl\":, \"opername\":, \"bb_bcolor\":, \"bb_head\":, \"bb_level\":, \"bb_id\":, \"rich_type\":, \"uservip_degree\":, \"content_style\": \"{\\\"color\\\":\\\"\\\",\\\"position\\\":}\" } ]} 其中timepoint、content_style中的color、content字段可以组成xml弹幕格式。 全部python代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport jsondef getHTMLText(url): try: r = requests.get(url, timeout=30) r.raise_for_status() r.encoding='utf-8' return r.text except Exception as e: print(e) return ''def get_tencent_danmu(url): video_info = json.loads(str([s for s in getHTMLText(url).split('\\n') if 'VIDEO_INFO' in str(s)]).strip('[\\'var VIDEO_INFO = ').strip('\\']')) duration = video_info['duration'] title = video_info['title'] vid = video_info['vid'] targetid = json.loads(getHTMLText('http://bullet.video.qq.com/fcgi-bin/target/regist?otype=json&amp;vid=' + vid).strip('QZOutputJson=').strip(';'))['targetid'] filename = 'XML/' + title + '.xml' contents = [] print('\\n' + title + ': ', end='') with open(filename, 'w', encoding='utf-8') as fout: fout.write('&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n') fout.write('&lt;i&gt;\\n') for i in range(int(duration) // 30 + 1): timestamp = i*30 print(i/2, end='min, ') response = getHTMLText('http://mfm.video.qq.com/danmu?timestamp=' + str(timestamp) + '&amp;target_id=' + targetid) if response == '': continue try: danmu = json.loads(response, strict=False) for j in danmu['comments']: illegal = False #标志是否有非法XML字符 for char in ['&lt;', '&gt;', '&amp;', '\\u0000', '\\b']: if char in j['content']: illegal = True break if illegal: continue timepoint = j['timepoint'] #弹幕发送时间 ct = 1 #弹幕样式 size = 20 #字体大小 # 获取颜色 if 'color' in j['content_style']: content_style = json.loads(j['content_style']) color = int(content_style['color'], 16) else: color = 16777215 content = j['content'] #弹幕内容 black_list = ['word'] if ':' in content: content = content.split(':')[1].strip('&nbsp;').strip(' ') if content not in contents and all(word not in content for word in black_list): contents.append(content.strip(' ').strip('&nbsp;')) fout.write('&lt;d p=\"' + str(timepoint) + ',' + str(ct) +',' + str(size) + ',' + str(color) + '\"&gt;' + content + '&lt;/d&gt;\\n') except Exception as e: continue fout.write('&lt;/i&gt;') 爱奇艺视频弹幕下载 打开一个爱奇艺视频 PC 网页端，其源码中的 page-info 字段： 12345678910111213141516171819202122232425262728293031323334353637{ \"albumId\":, \"albumName\":, \"imageUrl\":, \"tvId\":, \"vid\":, \"cid\":, \"isSource\":, \"contentType\":, \"vType\":, \"pType\":, \"pageNo\":, \"pageType\":, \"userId\":, \"pageUrl\":, \"tvName\":, \"isfeizhengpian\":, \"categoryName\":, \"categories\":, \"downloadAllowed\":, \"publicLevel\":, \"payMark\":, \"payMarkUrl\":, \"vipType\":[ ], \"qiyiProduced\":, \"exclusive\":, \"tvYear\":, \"duration\":\"::\", \"wallId\":, \"rewardAllowed\":, \"commentAllowed\":, \"heatShowTypes\":, \"videoTemplate\":, \"issueTime\":} 其中所需的字段是duration、tvName、albumId、tvId、cid。 duration由‘时：分：秒’格式转为秒： 12345duration_str = page_info['duration'].split(':')duration = 0for i in range(len(duration_str)-1): duration = (duration + int(duration_str[i])) * 60duration = duration + int(duration_str[-1]) 然后就可以通过albumId、tvId、cid得到弹幕：http://cmts.iqiyi.com/bullet/(%tvId[-4:-2]%)/(%tvId[-2:]%)/(%tvId%)_300_(%page%).z?rn=0.(%16位随机数%)&amp;business=danmu&amp;is_iqiyi=true&amp;is_video_page=true&amp;tvid=(%tvid%)&amp;albumid=(%albumid%)&amp;categoryid=(%cid%)&amp;qypid=01010021010000000000，其中tvId需要分割出倒数4-3位和倒数2-1位，page从1开始并且以1为增量，打开此链接得到(%tvId%)_300_(%page%).z的文件，这个文件是压缩的字节流需要解压。 Python中利用zlib库，dec = zlib.decompressobj(32 + zlib.MAX_WBITS) 和 b = dec.decompress('z文件').decode(\"utf-8\") 得到XML格式的弹幕（只截取了第一条弹幕）： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;danmu&gt; &lt;code&gt;&lt;/code&gt; &lt;data&gt; &lt;entry&gt; &lt;int&gt;&lt;/int&gt; &lt;list&gt; &lt;bulletInfo&gt; &lt;contentId&gt;&lt;/contentId&gt; &lt;content&gt;&lt;/content&gt; &lt;showTime&gt;1&lt;/showTime&gt; &lt;font&gt;&lt;/font&gt; &lt;color&gt;&lt;/color&gt; &lt;opacity&gt;&lt;/opacity&gt; &lt;position&gt;&lt;/position&gt; &lt;background&gt;&lt;/background&gt; &lt;contentType&gt;&lt;/contentType&gt; &lt;isReply&gt;&lt;/isReply&gt; &lt;likeCount&gt;&lt;/likeCount&gt; &lt;plusCount&gt;&lt;/plusCount&gt; &lt;dissCount&gt;&lt;/dissCount&gt; &lt;userInfo&gt; &lt;senderAvatar&gt;&lt;/senderAvatar&gt; &lt;uid&gt;&lt;/uid&gt; &lt;udid&gt;&lt;/udid&gt; &lt;name&gt;&lt;/name&gt; &lt;/userInfo&gt; &lt;/bulletInfo&gt; &lt;/list&gt; &lt;/entry&gt; &lt;/data&gt; &lt;sum&gt;&lt;/sum&gt; &lt;validSum&gt;&lt;/validSum&gt; &lt;duration&gt;&lt;/duration&gt; &lt;ts&gt;&lt;/ts&gt; &lt;/danmu&gt; 其中showTime、color、content字段可以组成xml弹幕格式（color需要从16进制转换成10进制）。 全部python代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport reimport jsonfrom random import randintimport zlibimport xml.etree.ElementTree as ETdef getHTMLText(url, encode): try: r = requests.get(url, timeout=30) r.raise_for_status() if encode == 'utf-8': r.encoding='utf-8' return r.text elif encode == 'byte': return r.content except Exception as e: print(e) return ''def get_iqiyi_danmu(url): page_info = json.loads(re.search(r'page-info=\\'(.*)\\'( *):video-info', getHTMLText(url, 'utf-8')).group(1)) duration_str = page_info['duration'].split(':') duration = 0 for i in range(len(duration_str)-1): duration = (duration + int(duration_str[i])) * 60 duration = duration + int(duration_str[-1]) title = page_info['tvName'] albumid = page_info['albumId'] tvid = page_info['tvId'] categoryid = page_info['cid'] page = duration // (60 * 5) + 1 filename = 'XML/' + title + '.xml' contents = [] with open(filename, 'w', encoding='utf-8') as fout: fout.write('&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n') fout.write('&lt;i&gt;\\n') for i in range(duration // (60 * 5) + 1): dec = zlib.decompressobj(32 + zlib.MAX_WBITS) try: b = dec.decompress(getHTMLText('http://cmts.iqiyi.com/bullet/' + str(tvid)[-4:-2] + '/' + str(tvid)[-2:] + '/' + str(tvid) + '_300_' + str(i+1) + '.z?rn=0.' + ''.join(['%s' % randint(0, 9) for num in range(0, 16)]) + '&amp;business=danmu&amp;is_iqiyi=true&amp;is_video_page=true&amp;tvid=' + str(tvid) + '&amp;albumid=' + str(albumid) + '&amp;categoryid=' + str(categoryid) + '&amp;qypid=01010021010000000000', 'byte')) print('page: ' + str(i)) except: print(print('page not found: ' + str(i))) try: root = ET.fromstring(b.decode('utf-8')) except Exception as e: print(e) continue for bulletInfo in root.iter('bulletInfo'): timepoint = bulletInfo[3].text #弹幕发送时间 ct = 1 #弹幕样式 size = 20 #字体大小 color = int(bulletInfo[5].text, 16) #颜色 content = bulletInfo[1].text #弹幕内容 black_list = ['word'] if content not in contents and all(word not in content for word in black_list): contents.append(content) fout.write('&lt;d p=\"' + str(timepoint) + ',' + str(ct) +',' + str(size) + ',' + str(color) + '\"&gt;' + content + '&lt;/d&gt;\\n') fout.write('&lt;/i&gt;') 优酷视频弹幕下载 打开一个优酷视频 PC 网页端，其源码中的 window.PageConfig 字段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152window.PageConfig = { transfer_mode: , isDRM: , videoCategoryId: , isSimple: , videoId: , newVersion: , isDebug: , pid: , homeHost: , youku_homeurl: , catId: , playmode: , videoOwner: , videoOwner_en: , videoId2: , currentEncodeVid: , catName: , seconds: , bullet: , transfer: , panorama: , folderId: , fpos: , forder: , ftotalpos: , showid_en: , showid: , cp: , paid: , showtype: , tabs: , singerId: , loadinglogo: , lottery_open_sidetool: , lottery_id_sidetool: , lottery_sidetool: , page: { type: , isdatetype: , year: , firstMon: , lastMon: , currMon: , episodeLast: , parentvideoid: , compeleted: }, copytoclip: , playerUrl: };var str = \"&amp;ct=c&amp;cs=&amp;td=&amp;s=&amp;v=&amp;u=&amp;paid=&amp;tt=\"; 其中所需的字段是seconds、tt、videoId。 然后就可以通过videoId得到弹幕：https://service.danmu.youku.com/list?mat=(%mat%)&amp;ct=1001&amp;iid=(%videoId%)，其中mat从0开始并且以1为增量，打开此链接得到（只截取了第一条弹幕）： 123456789101112131415161718192021222324252627{ \"count\": , \"filtered\": , \"result\": [{ \"aid\": , \"content\": \"\", \"createtime\": , \"ct\": , \"extFields\": { \"voteUp\": }, \"id\": , \"iid\": , \"ipaddr\": , \"level\": , \"lid\": , \"mat\": , \"ouid\": , \"playat\": , \"propertis\": \"{\\\"pos\\\":,\\\"size\\\":,\\\"effect\\\":,\\\"color\\\":,\\\"dmfid\\\":}\", \"status\": , \"type\": , \"uid\": , \"ver\": }], \"scm\": \"0\"} 其中playat、propertis中的color、content字段可以组成xml弹幕格式。 全部python代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import urllib.requestimport reimport jsondef get_response(url): req = urllib.request.Request(url) req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = urllib.request.urlopen(req).read().decode('utf-8') return responsedef get_youku_danmu(url): res = get_response(url) title = re.search(r'&lt;title&gt;(.*)&lt;/title&gt;', res).group(1).split('—')[0] iid = re.search(r'videoId: \\'(\\d*)\\'', res).group(1) duration = float(re.search(r'seconds: \\'(.*)\\',', res).group(1)) filename = 'XML/' + title.split('集 ')[0] + '.xml' contents = [] with open(filename, 'w', encoding='utf-8') as fout: fout.write('&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n') fout.write('&lt;i&gt;\\n') for mat in range(int(duration) // 60 + 1): response = get_response('https://service.danmu.youku.com/list?mat=' + str(mat) + '&amp;ct=1001&amp;iid=' + iid) danmu = json.loads(response) print(str(mat) + '\\tresult:' + str(len(danmu['result']))) for i in range(len(danmu['result'])): illegal = False #标志是否有非法XML字符 for char in ['&lt;', '&gt;', '&amp;', '\\u0000', '\\b']: if char in danmu['result'][i]['content']: illegal = True break if illegal: continue playat = danmu['result'][i]['playat']/1000 #弹幕发送时间 ct = 1 #弹幕样式 size = 20 #字体大小 # 获取颜色 if 'color' in danmu['result'][i]['propertis']: propertis = json.loads(danmu['result'][i]['propertis']) color = propertis['color'] else: color = 16777215 content = danmu['result'][i]['content'] #弹幕内容 black_list = ['word'] if content not in contents and all(word not in content for word in black_list): contents.append(content) fout.write('&lt;d p=\"' + str(playat) + ',' + str(ct) +',' + str(size) + ',' + str(color) + '\"&gt;' + content + '&lt;/d&gt;\\n') fout.write('&lt;/i&gt;') 芒果视频弹幕下载 打开一个芒果视频 PC 网页端，其网址（以 https://www.mgtv.com/b/9015/4828668.html 为例）中以 / 分割，倒数第二位是 cid，倒数第一位是 vid。 从源码中 &lt;title&gt;霸王别姬 - 视频在线观看 - 霸王别姬 - 芒果TV&lt;/title&gt; 可获得 title。 然后就可以通过 cid 和 vid 得到弹幕：https://galaxy.bz.mgtv.com/rdbarrage?vid=(%vid%)&amp;cid=(%cid%)&amp;time=(%time%)，其中 time 从 0 开始并且下一个 time 的值可从弹幕中得到，打开此链接得到（只截取了第一条弹幕）： 123456789101112131415161718{ \"status\":, \"msg\":\"操作成功\", \"seq\":\"\", \"data\":{ \"next\":, \"interval\":, \"items\":[ { \"id\":, \"type\":, \"uid\":, \"content\":, \"time\": } ] }} 其中time、content字段可以组成xml弹幕格式。 全部python代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import urllib.requestimport jsonimport sysimport iosys.stdout = io.TextIOWrapper(sys.stdout.buffer,encoding='utf8')def get_response(url): req = urllib.request.Request(url) req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = urllib.request.urlopen(req).read().decode('utf-8') return responsedef get_mangguo_danmu(url): cid = url.split('/')[4] vid = url.split('/')[5].strip('.html') video_info = json.loads(get_response('https://pcweb.api.mgtv.com/video/info?vid=8244411&amp;cid=335811')) title = video_info['data']['info']['videoName'] filename = 'XML/' + title + '.xml' contents = [] with open(filename, 'w', encoding='utf-8') as fout: fout.write('&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\\n') fout.write('&lt;i&gt;\\n') time = 0 while True: print('https://galaxy.bz.mgtv.com/rdbarrage?version=2.0.0&amp;vid=' + vid + '&amp;cid=' + cid + '&amp;time=' + str(time)) danmu = json.loads(get_response('https://galaxy.bz.mgtv.com/rdbarrage?version=2.0.0&amp;vid=' + vid + '&amp;cid=' + cid + '&amp;time=' + str(time))) print(str(time)) if danmu['data']['items'] == None: break for j in danmu['data']['items']: illegal = False #标志是否有非法XML字符 for char in ['&lt;', '&gt;', '&amp;', '\\u0000', '\\b']: if char in j['content']: illegal = True break if illegal: continue timepoint = j['time']/1000 #弹幕发送时间 ct = 1 #弹幕样式 size = 20 #字体大小 color = 16777215 #弹幕颜色 content = j['content'] #弹幕内容 black_list = ['word'] if content not in contents and all(word not in content for word in black_list): contents.append(content) fout.write('&lt;d p=\"' + str(timepoint) + ',' + str(ct) +',' + str(size) + ',' + str(color) + '\"&gt;' + content + '&lt;/d&gt;\\n') time = danmu['data']['next'] fout.write('&lt;/i&gt;') 视频下载 You-Get 是一个命令行程序，提供便利的方式来下载网络上的媒体信息。 you-get 的功用: 1. 下载流行网站的音频、视频 (查看完整支持列表) 2. 在媒体播放器中观看在线视频，脱离浏览器与广告 3. 下载喜欢的网页上的图片 4. 下载任何非 HTML 内容，例如二进制文件 you-get 主要在 linux 等开源平台上运行，由于家用电脑大多为 windows 系统，安装方法如下： 下载相关安装包 以下是必要依赖，需要单独安装，除非于 Windows 下使用预包装包: Python 3 FFmpeg 或者 [Libav] https://libav.org/ 通过 pip 安装 you-get 的官方版本通过 PyPI 分发，可从 PyPI 镜像中通过 pip 包管理器安装。务必使用版本 3 的 pip: $ pip3 install you-get Git clone $ git clone git://github.com/soimort/you-get.git 将源码解压到任意目录即可 升级 考虑到 you-get 安装方法的差异，请使用: $ pip3 install --upgrade you-get 或下载最新更新: $ you-get https://github.com/soimort/you-get/archive/master.zip 使用 you-get 进入解压文件夹 you-get-develop 下，在该目录下打开 Windows Powershell。 输入 python you-get 视频网址即可使用下载功能（视频保存在 you-get-develop 目录下）。 腾讯视频下载 打开腾讯视频播放页，打开控制台（F12），Network 选项下搜索 \"ts.m3u8\" 字段，找到类似下面的网址： https://apd-(32位字符串).v.smtcdns.com/moviets.tc.qq.com/(44位字符串)/uwMROfz0r5xgoaQXGdGnC2df64hwtZlCglRDKOjEZ_qQW-eC/(160位字符串)/(vid).(数字).ts.m3u8?ver=4 此 m3u8 文件存有 ts 索引相对地址： 1234567#EXTM3U#EXT-X-VERSION:#EXT-X-MEDIA-SEQUENCE:#EXT-X-TARGETDURATION:#EXT-X-PLAYLIST-TYPE:#EXTINF:(时长),0(#)_(vid).(数字).(#).ts?index=(数字)&amp;start=(数字)&amp;end=(数字)&amp;brs=(数字)&amp;bre=(数字)&amp;ver=4 可以利用如下代码下载并且合并ts文件： 1234567891011121314151617import urllib.requestdef get_response(url): req = urllib.request.Request(url) req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36') response = urllib.request.urlopen(req).read() return responseurl_m3u8 = '(m3u8地址)'EXTM3U = get_response(url_m3u8).decode('utf-8').split('\\n')ts = [i for i in EXTM3U if 'ts' in i]url_header = url_m3u8[::-1].split('/', 1)[1][::-1]for i in ts: url_ts = url_header + '/' + i with open('(文件名).ts', 'ab') as f: f.write(get_response(url_ts)) 批量进行弹幕 ASS 转换 安装 selenium pip install selenium 如果用 chrome 查看 chrome 的版本号 (Chromium 72.0.3626.121) https://chromedriver.storage.googleapis.com/LATEST_RELEASE_72.0.3626 https://chromedriver.storage.googleapis.com/index.html?path=72.0.3626.69/ 下载相应 win32 版本 解压放入 python 根目录 修改 common.js startDownload('\\ufeff' + ass, name.replace(/\\.[^.]*$/, '') + '.ass'); 改为 return ass;","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Crawler","slug":"Crawler","permalink":"https://lxmymjr.github.io/tags/Crawler/"}]},{"title":"Firebase 存储教程","slug":"Firebase存储教程","date":"2019-03-19T06:38:06.000Z","updated":"2021-09-16T02:56:10.893Z","comments":true,"path":"contents/Firebase存储教程.html","link":"","permalink":"https://lxmymjr.github.io/contents/Firebase%E5%AD%98%E5%82%A8%E6%95%99%E7%A8%8B.html","excerpt":"Firebase 云端存储 (Cloud Storage) 是 Google 官方提供的一项功能强大、操作简单且经济实惠的对象存储服务，可轻松支持类似 Google 这种规模级别的应用。无论网络质量如何，适用于 Cloud Storage 的 Firebase SDK 都能为 Firebase 应用提供 Google 安全品质的文件上传和下载服务。可以使用 SDK 来存储图片、音频、视频或其他由用户生成的内容。在服务器上，可以使用 Google Cloud Storage 来访问相同的文件。","text":"Firebase 云端存储 (Cloud Storage) 是 Google 官方提供的一项功能强大、操作简单且经济实惠的对象存储服务，可轻松支持类似 Google 这种规模级别的应用。无论网络质量如何，适用于 Cloud Storage 的 Firebase SDK 都能为 Firebase 应用提供 Google 安全品质的文件上传和下载服务。可以使用 SDK 来存储图片、音频、视频或其他由用户生成的内容。在服务器上，可以使用 Google Cloud Storage 来访问相同的文件。 准备工作 注册成为 Firebase 开发者 在 Firebase Console 注册账号并登陆。 添加项目 点击 “添加项目”，填写项目名称和国家 / 地区。添加完成后进入项目。 添加应用 在此只演示安卓系统，点击 “Overview 概览” 页面的 “将 Firebase 添加到您的 Android 应用” 按钮。填写 Android 应用包名（不可更改），别名（选填），调试签名证书 SHA1（可选）。 下载配置文件 点击 “注册应用”，下载配置文件 “google-services.json”。（此配置文件也可以在 Overview 的右边设置中的 “项目设置” 中查看、下载。） 在 Android Studio 中切换到项目视图，查看项目根目录（即 app 目录），并将配置文件放入到此根目录下。 服务器端 本文使用 Python 作为服务器脚本语言。 Google Cloud Storage 源码：Google Cloud Storage，API Document 环境配置 pip 方式：pip install firebase_admin 服务端主函数 1234567891011121314151617import osimport firebase_adminfrom firebase_admin import credentialsfrom firebase_admin import storagecred = credentials.Certificate('path/to/serviceAccountKey.json')firebase_admin.initialize_app(cred, { 'storageBucket': '&lt;BUCKET_NAME&gt;.appspot.com'})bucket = storage.bucket()blob = bucket.blob('path/to/file')file_string = blob.download_as_string() #以字符串的形式打印存储的文件with open('path/to/file', 'wb') as file: blob.download_to_file(file) #以byte的形式下载文件到本地 blobs_list = list(bucket.list_blobs(prefix='xxx')) #以blob形式返回以’xxx‘为前缀的文件列表 Android 上的 Cloud Storage 前提条件： 安装 Firebase SDK。 在 Firebase 控制台中将应用添加到 Firebase 项目。 设置公共访问权限 Cloud Storage for Firebase 提供了一种声明式规则语言，可用于定义数据的组织结构方式、将数据编入索引的方式，以及何时可以读取和写入数据。默认情况下，对 Storage 的读写权限是有限制的，只有通过身份验证的用户才能读写数据。要在不设置身份验证的情况下开始使用 Storage，可以将规则配置为允许公共访问。 进入 firebase 控制台 进入 firebase 项目 左侧栏中点击 “Develop-Storage” 选项卡中选择 “规则” 右侧改写规则为公开规则： 1234567service firebase.storage { match /b/{bucket}/o { match /{allPaths=**} { allow read, write; } }} 这会使得 Storage 向所有人开放，包括不使用应用的用户，因此在设置身份验证时，请务必重新限制对 Storage 的访问权限。 Android 客户端 官方集成文档：Android 上的 Cloud Storage 使用入门 添加所需的依赖 向根项目级 build.gradle 文件添加规则，以纳入 Google 服务插件： 1234567buildscript { // ... dependencies { // ... classpath 'com.google.gms:google-services:4.3.3' #修改为最新版本 }} 在模块 Gradle 文件（通常是 app/build.gradle）中，在文件的底部添加 apply plugin 代码行，以启用 Gradle 插件： 1234567891011apply plugin: 'com.android.application'apply plugin: 'com.google.gms.google-services'android { // ...}dependencies { // ... implementation 'com.google.firebase:firebase-storage:19.1.1' #修改为最新版本 implementation \"com.google.firebase:firebase-storage-ktx:19.1.1\" #如果是kotlin语言则加上-ktx，修改为最新版本} 设置 Cloud Storage 访问存储分区的第一步是在 onCreate 函数中创建一个 FirebaseStorage 实例： 1FirebaseStorage storage = FirebaseStorage.getInstance(); 1val storage = Firebase.storage 创建引用 要上传、下载或删除文件，或要获取或更新文件的元数据，请创建引用。引用可以看作是指向云端文件的指针。由于引用属于轻型项目，因此可以根据需要创建多个引用。 这些引用可以重复用于多个操作。 引用是使用 FirebaseStorage 单例实例并调用其 getReference () 方法创建的。 1StorageReference storageRef = storage.getReference(); 1val storageRef = storage.reference 可以在现有引用上使用 getChild () 方法，创建一个对树中较低位置的引用。比如文件存储在‘aaa’文件夹下‘bbb’文件中，则： 1StorageReference fileRef = storageRef.child(\"aaa/bbb\"); 1val riversRef = storageRef.child(\"aaa/bbb\") 上传 要将文件上传到 Cloud Storage，首先要创建对文件的完整路径（包括文件名）的引用。 创建适当的引用后，可以调用 putBytes ()、putFile () 或 putStream () 方法将文件上传到 Cloud Storage。 通过内存中的数据上传 putBytes () 方法是将文件上传到 Cloud Storage 的最简单方法。putBytes () 需要一个 byte [] 并返回 UploadTask，可以用它来管理和监控上传状态。 123456789101112131415byte[] data;UploadTask uploadTask = mountainsRef.putBytes(data);uploadTask.addOnFailureListener(new OnFailureListener() { @Override public void onFailure(@NonNull Exception exception) { // Handle unsuccessful uploads }}).addOnSuccessListener(new OnSuccessListener&lt;UploadTask.TaskSnapshot&gt;() { @Override public void onSuccess(UploadTask.TaskSnapshot taskSnapshot) { // taskSnapshot.getMetadata() contains file metadata such as size, content-type, etc. // ... }}); 123456789101112131415// Get the data from an ImageView as bytesimageView.isDrawingCacheEnabled = trueimageView.buildDrawingCache()val bitmap = (imageView.drawable as BitmapDrawable).bitmapval baos = ByteArrayOutputStream()bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos)val data = baos.toByteArray()var uploadTask = mountainsRef.putBytes(data)uploadTask.addOnFailureListener { // Handle unsuccessful uploads}.addOnSuccessListener { // taskSnapshot.metadata contains file metadata such as size, content-type, etc. // ...} 由于 putBytes () 接受了 byte []，因此它需要应用立即将文件的全部内容保存在内存中。请考虑使用 putStream () 或 putFile () 以使用较少的内存。 通过数据流上传 putStream () 方法是将文件上传到 Cloud Storage 最通用的方法。putStream () 接受了 InputStream 并返回 UploadTask，可以使用它来管理和监控上传状态。 123456789101112131415InputStream stream = new FileInputStream(new File(\"path/to/file\"));uploadTask = mountainsRef.putStream(stream);uploadTask.addOnFailureListener(new OnFailureListener() { @Override public void onFailure(@NonNull Exception exception) { // Handle unsuccessful uploads }}).addOnSuccessListener(new OnSuccessListener&lt;UploadTask.TaskSnapshot&gt;() { @Override public void onSuccess(UploadTask.TaskSnapshot taskSnapshot) { // taskSnapshot.getMetadata() contains file metadata such as size, content-type, etc. // ... }}); 123456789val stream = FileInputStream(File(\"path/to/file\"))uploadTask = mountainsRef.putStream(stream)uploadTask.addOnFailureListener { // Handle unsuccessful uploads}.addOnSuccessListener { // taskSnapshot.metadata contains file metadata such as size, content-type, etc. // ...} 从本地文件上传 可以使用 putFile () 方法上传设备上的本地文件，例如相机中的照片和视频。putFile () 需要一个 File 并返回 UploadTask，可以使用它来管理和监控上传状态。 1234567891011121314151617Uri file = Uri.fromFile(new File(\"path/to/file\"));StorageReference fileRef = storageRef.child(\"folder/\"+file.getLastPathSegment());uploadTask = fileRef.putFile(file);// Register observers to listen for when the download is done or if it failsuploadTask.addOnFailureListener(new OnFailureListener() { @Override public void onFailure(@NonNull Exception exception) { // Handle unsuccessful uploads }}).addOnSuccessListener(new OnSuccessListener&lt;UploadTask.TaskSnapshot&gt;() { @Override public void onSuccess(UploadTask.TaskSnapshot taskSnapshot) { // taskSnapshot.getMetadata() contains file metadata such as size, content-type, etc. // ... }}); 1234567891011var file = Uri.fromFile(File(\"path/to/file\"))val riversRef = storageRef.child(\"folder/${file.lastPathSegment}\")uploadTask = riversRef.putFile(file)// Register observers to listen for when the download is done or if it failsuploadTask.addOnFailureListener { // Handle unsuccessful uploads}.addOnSuccessListener { // taskSnapshot.metadata contains file metadata such as size, content-type, etc. // ...}","categories":[{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/categories/Android/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/tags/Android/"}]},{"title":"Firebase 推送教程","slug":"Firebase推送教程","date":"2017-10-28T15:37:26.000Z","updated":"2021-09-16T02:56:10.893Z","comments":true,"path":"contents/Firebase推送教程.html","link":"","permalink":"https://lxmymjr.github.io/contents/Firebase%E6%8E%A8%E9%80%81%E6%95%99%E7%A8%8B.html","excerpt":"Firebase 云信息传递 (FCM) 是 Google 官方提供的一种跨平台消息传递解决方案，可供免费、可靠地传递消息。","text":"Firebase 云信息传递 (FCM) 是 Google 官方提供的一种跨平台消息传递解决方案，可供免费、可靠地传递消息。 准备工作 注册成为 Firebase 开发者 在 Firebase Console 注册账号并登陆。 添加项目 点击 “添加项目”，填写项目名称和国家 / 地区。添加完成后进入项目。 添加应用 在此只演示安卓系统，点击 “Overview 概览” 页面的 “将 Firebase 添加到您的 Android 应用” 按钮。填写 Android 应用包名（不可更改），别名（选填），调试签名证书 SHA1（可选）。 下载配置文件 点击 “注册应用”，下载配置文件 “google-services.json”。（此配置文件也可以在 Overview 的右边设置中的 “项目设置” 中查看、下载。） 在 Android Studio 中切换到项目视图，查看项目根目录（即 app 目录），并将配置文件放入到此根目录下。 修改 Gradle：项目级 build.gradle（&lt;project&gt;/build.gradle）： 123456buildscript { dependencies { // Add this line classpath 'com.google.gms:google-services:3.1.0' }} 应用级 build.gradle（&lt;project&gt;/&lt;app-module&gt;/build.gradle）： 123...// Add to the bottom of the file （一定要放最后）apply plugin: 'com.google.gms.google-services' 按 IDE 中显示的栏中的 “立即同步”（Sync now）。 服务器端 本文使用 Python 作为服务器脚本语言。 PyFCM 源码：PyFCM 环境配置 pip 方式：pip install pyfcm 服务端主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pyfcm import FCMNotificationpush_service = FCMNotification(api_key=\"&lt;api-key&gt;\")# 或者设置一个代理# proxy_dict = { \"http\" : \"http://127.0.0.1\", \"https\" : \"http://127.0.0.1\", }# push_service = FCMNotification(api_key=\"&lt;api-key&gt;\", proxy_dict=proxy_dict)# api-key可以从https://console.firebase.google.com/project/&lt;project-name&gt;/settings/cloudmessaging获得，即firebase console→对应项目→设置→云消息传递→服务器密钥。message_title = \"xxxxx\" #通知的标题message_body = \"xxxxx\" #通知的内容data_message = { \"a\" : \"b\", \"c\" : \"d\", \"e\" : \"f\"} # 数据消息，为键值对# 如果是发送给单台设备。registration_id = \"&lt;device registration_id&gt;\" #Android应用的token# 发送通知result = push_service.notify_single_device(registration_id=registration_id, message_title=message_title, message_body=message_body)# 发送数据result = push_service.single_device_data_message(registration_id=registration_id, data_message=data_message)# 发送带有数据的通知result = push_service.notify_single_device(registration_id=registration_id, message_body=message_body, data_message=data_message)# 如果是发送给多台设备消息通知。registration_ids = [\"&lt;device registration_id 1&gt;\", \"&lt;device registration_id 2&gt;\", ...]# 发送通知result = push_service.notify_multiple_devices(registration_ids=registration_ids, message_title=message_title, message_body=message_body)# 发送数据result = push_service.multiple_devices_data_message(registration_ids=registration_ids, data_message=data_message)# 发送带有数据的通知result = push_service.notify_multiple_devices(registration_ids=registration_ids, message_body=message_body, data_message=data_message)# 其他配置# 发送一个高优先级的数据extra_kwargs = { 'priority': 'high'}result = push_service.notify_single_device(registration_id=registration_id, data_message=data_message, extra_kwargs=extra_kwargs)# 发送一个低优先级的数据# low_priority默认为Falseresult = push_service.notify_multiple_devices(registration_ids=registration_ids, message_body=message, low_priority=True)# 获得有效的registration_ids（可以用于清洗数据库中有效的registration_ids）registration_ids = ['reg id 1', 'reg id 2', 'reg id 3', 'reg id 4', ...]valid_registration_ids = push_service.clean_registration_ids(registration_ids)# 发送消息至主题result = push_service.notify_topic_subscribers(topic_name=\"xxx\", message_body=message)# 有条件的发送消息至主题，如果用户订阅了TopicA和TopicB或者TopicA和TopicC则能收到消息。topic_condition = \"'TopicA' in topics &amp;&amp; ('TopicB' in topics || 'TopicC' in topics)\"result = push_service.notify_topic_subscribers(message_body=message, condition=topic_condition)# 其他可选配置collapse_key (str): 设置折叠消息delay_while_idle (bool): 如果设置为真则表示消息将不会送达直到设备被激活。time_to_live (int): 消息将会被保留多少秒，最多保留4周，默认值也是4周。restricted_package_name (str): 应用包名必须匹配才收的到消息。dry_run (bool): 如果设置为真则表示没有消息将会被送达，但是请求还是会被测试。# 返回数据response_dict = { 'multicast_ids': list(), #多播消息的唯一ID 'success': 0, #没有报错的消息数目 'failure': 0, #没有处理的消息数目 'canonical_ids': 0, #包括标准registration token的结果数目 'results': list(), #表示消息状态的字典 'topic_message_id': None or str} Android 上的主题消息传递 在发布 / 订阅模式下，利用 FCM 主题消息传递功能，可以将消息发送至已经选择加入特定主题的多台设备。根据需要撰写主题消息，FCM 将处理消息路由并将消息可靠地传送至正确的设备。 关于主题，请注意以下事项： 主题消息传递不限制每个应用拥有的主题和订阅数。 目前，主题消息的有效负载不得超过 2KB。 主题消息传递最适合传递新闻、天气或其他可通过公开途径获得的信息等内容。 主题消息针对吞吐量（而非延迟）进行了优化。要将消息快速安全地传送到单台设备或小规模设备组，应将消息定位至注册令牌，而非主题。 如果需要向一位用户的多台设备发送消息，可考虑针对这些使用情形进行设备组消息传递。 设置消息的优先级 普通优先级：这是数据消息的默认优先级。普通优先级消息不会让休眠设备打开网络连接，为了省电，它们可能会被延迟传递。如果是对时间不太敏感的消息，例如新电子邮件通知或其他要同步的数据，建议选择普通传递优先级。 高优先级：这是通知消息的默认优先级。FCM 会立即尝试传递高优先级消息，允许 FCM 服务在可能的情况下唤醒休眠设备并打开与应用服务器的网络连接。例如，带有即时通讯、聊天或语音通话提醒功能的应用通常需要打开网络连接并确保 FCM 及时将消息传递给设备。如果消息属于时间关键型且需要用户立刻交互，请设置高优先级，但需要注意的是，将消息设置为高优先级会比普通优先级耗费更多电池电量。 有效值为 normal 和 high。 不可折叠消息和可折叠消息 不可折叠消息表示每一条消息都将被传递至设备。不可折叠消息可传递一些有用内容至手机应用，从而联系服务器以获取数据，这与 “ping” 相反。默认情况下，消息不可折叠，但通知消息（始终是可折叠消息）除外。 聊天消息或关键消息都是典型的不可折叠消息。例如，在 IM 应用中，可能想要传递每一条消息，因为它们的内容各不相同。 在不折叠的情况下，最多可存储 100 条消息。达到此限值后，所有存储的消息都将被舍弃。设备在重新联网后将收到一条特殊消息，提示已达到此上限。之后，应用可以正常处理该状况，一般情况下会请求与应用服务器完全同步。 可折叠消息在还未被传递至设备的情况下可能会被新消息替代。 两种常见的可折叠消息是 “发送以同步” 消息和通知消息。“发送以同步” 消息是一个 “ping”，它会告诉移动应用从服务器同步数据。为用户更新最新比分的体育应用就属于这种消息。只有最新的消息是相关的。 要将消息标记为可折叠，请在消息有效负载中添加 collapse_key 参数。FCM 允许应用服务器在任意指定时间内为每台设备使用最多 4 个不同的折叠键。也就是说，FCM 连接服务器可以为每台设备同时存储 4 条不同的可折叠 “发送以同步” 消息，每一条都含有不同的折叠键。如果超出此限值，FCM 将仅保留 4 个折叠键，具体保留哪几个不一定。 Android 客户端 官方集成文档：在 Android 上设置 Firebase 云消息传递客户端应用 将 Firebase 添加到 Android 项目 前提条件： 运行 Android 4.0 (Ice Cream Sandwich) 或更高版本以及 Google Play 服务 11.0.4 或更高版本的设备。 Google 代码库中的 Google Play Services SDK，可通过 Android SDK Manager 获得。 最新版本的 Android Studio，1.5 版或更高版本。 如果使用最新版本的 Android Studio（2.2 版或更高版本），建议使用 Firebase 智能助理来将的应用关联至 Firebase。Firebase 智能助理可以关联现有的项目，或者为创建一个新项目，并自动安装任何必要的 Gradle 依赖项。 依次点击 Tools&gt;Firebase 以打开 Assistant 窗口。 点击以展开所列功能之一（例如 Cloud Messaging），然后点击所提供的教程链接。 点击 Connect to Firebase 按钮以关联至 Firebase，并向应用添加必要的代码。 添加所需的依赖 向根项目级 build.gradle 文件添加规则，以纳入 Google 服务插件： 1234567buildscript { // ... dependencies { // ... classpath 'com.google.gms:google-services:3.1.0' }} 在模块 Gradle 文件（通常是 app/build.gradle）中，在文件的底部添加 apply plugin 代码行，以启用 Gradle 插件： 1234567891011apply plugin: 'com.android.application'android { // ...}dependencies { // ... compile 'com.google.firebase:firebase-messaging:11.4.2' #修改为最新版本 compile 'com.google.android.gms:play-services-base:11.4.2' #修改为最新版本}// 一定要放在最底部apply plugin: 'com.google.gms.google-services' 如果 FCM 对于 Android 应用的功能至关重要，请务必在应用的 build.gradle 中设置 minSdkVersion 8 或更高版本。这可确保 Android 应用无法安装在不能让其正常运行的环境中。 修改应用清单 AndroidManifest.xml 一项继承 FirebaseMessagingService 的服务。如果希望在后台进行除接收应用通知之外的消息处理，则必须添加此服务。要接收前台应用中的通知、接收数据有效负载以及发送上行消息等，必须继承此服务。 12345&lt;service android:name=\".MyFirebaseMessagingService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.google.firebase.MESSAGING_EVENT\"/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 一项继承 FirebaseInstanceIdService 的服务，用于处理注册令牌的创建、轮替和更新。如果要发送至特定设备或者创建设备组，则必须添加此服务。 12345&lt;service android:name=\".MyFirebaseInstanceIDService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.google.firebase.INSTANCE_ID_EVENT\"/&gt; &lt;/intent-filter&gt;&lt;/service&gt; （可选）在应用组件中，用于设置通知的默认图标、颜色和通知渠道（Android O 的新功能）的元数据元素。如果传入的消息未明确设置图标、颜色或通知渠道，则 Android 会使用这些值。 123456&lt;meta-data android:name=\"com.google.firebase.messaging.default_notification_icon\" android:resource=\"@drawable/ic_stat_ic_notification\" /&gt;&lt;meta-data android:name=\"com.google.firebase.messaging.default_notification_color\" android:resource=\"@color/colorAccent\" /&gt; 获取设备注册令牌 初次启动应用时，FCM SDK 会为客户端应用实例生成一个注册令牌。如果希望定位至单台设备或创建设备组，则需要通过继承 FirebaseInstanceIdService 来访问此令牌。 令牌会在初始启动后生成，建议检索最新更新的注册令牌。 注册令牌可能会在发生下列情况时更改： - 应用删除实例 ID - 应用在新设备上恢复 - 用户卸载 / 重新安装应用 - 用户清除应用数据 检索当前注册令牌 如果需要检索当前令牌，调用 FirebaseInstanceId.getInstance ().getToken ()。如果令牌尚未生成，此方法将返回 null。 监控令牌的生成 每次生成新的令牌时，都会触发 onTokenRefresh 回调，因此，在上下文中调用 getToken 可以确保访问的是当前可用的注册令牌。确保已将服务添加到清单文件中，然后在 onTokenRefresh 的上下文中调用 getToken，并记录相应值，如下所示： 12345678@Overridepublic void onTokenRefresh() { // 获得注册令牌 String refreshedToken = FirebaseInstanceId.getInstance().getToken(); Log.d(TAG, \"Refreshed token: \" + refreshedToken); // 后续操作，如发送令牌到服务器 sendRegistrationToServer(refreshedToken);} 获取该令牌后，可以将其发送到应用服务器并进行存储。 检查 Google Play 服务 依靠 Play 服务 SDK 运行的应用在访问 Google Play 服务功能之前，应始终检查设备是否拥有兼容的 Google Play 服务 APK。建议在以下两个位置进行检查：主 Activity 的 onCreate () 方法中，及其 onResume () 方法中。在 onCreate () 中检查可确保该应用在检查成功之前无法使用。在 onResume () 中检查可确保当用户通过一些其他方式返回正在运行的应用（比如通过返回按钮）时，检查仍将继续进行。 如果设备没有兼容的 Google Play 服务版本，应用可以调用 GoogleApiAvailability.makeGooglePlayServicesAvailable(this)，以便让用户从 Play 商店下载 Google Play 服务，需要 import com.google.android.gms.common.GoogleApiAvailability; 为客户端应用订阅主题 客户端应用可以订阅任何现有主题，也可创建新主题。当客户端应用订阅新的主题名称（Firebase 项目中尚不存在的名称）时，系统会在 FCM 中创建使用这个名称的新主题，随后任何客户端都可订阅该主题。 若要订阅某个主题，客户端应用需使用 FCM 主题名称调用 Firebase 云消息传递 subscribeToTopic ()：FirebaseMessaging.getInstance().subscribeToTopic(\"news\"); 若要退订，客户端应用需使用主题名称调用 Firebase 云消息传递 unsubscribeFromTopic ()。 处理消息 要接收消息，使用继承 FirebaseMessagingService 的服务。重写 onMessageReceived 和 onDeletedMessages 回调。 在收到消息后的 10 秒内处理该消息。超过 10 秒后，Android 无法保证能够执行，并可能随时终止进程。如果应用需要更多时间来处理消息，使用 Firebase Job Dispatcher。 onMessageReceived 是为大多数消息类型提供的，但有以下例外情况：当应用在后台时送达的通知消息。在这种情况下，通知将传送至设备的系统任务栏。默认情况下，用户点按通知即可打开应用启动器。同时具备通知和数据有效负载的消息，无论应用在前台还是后台。在这种情况下，通知将传送至设备的系统任务栏，数据有效负载则传送至启动器 Activity 的 intent 的 extras 参数中。 应用状态 通知 数据 两者 前台 onMessageReceived onMessageReceived onMessageReceived 后台 系统任务栏 onMessageReceived 通知：系统任务栏数据：intent 的 extras 参数。 注意：当需要发送通知（和数据）但是又希望不需要用户打开通知消息的情况下进行其他操作，则可以只发送数据，但是在 onMessageReceived 函数中手动生成 notification。 重写 onMessageReceived 1234567891011121314151617181920@Overridepublic void onMessageReceived(RemoteMessage remoteMessage) { Log.d(TAG, \"From: \" + remoteMessage.getFrom()); // 检查是否收到数据 if (remoteMessage.getData().size() &gt; 0) { Log.d(TAG, \"Message data payload: \" + remoteMessage.getData()); if (/*如果数据处理超过10秒*/ true) { scheduleJob(); } else { // 如果数据处理在10秒以内 handleNow(); } } // 检查数据是否携带通知 if (remoteMessage.getNotification() != null) { Log.d(TAG, \"Message Notification Body: \" + remoteMessage.getNotification().getBody()); }} 如果服务器只发送数据，但是需要应用主动生成通知则： 1234567891011121314151617181920212223242526272829303132public class MyFirebaseMessagingService extends FirebaseMessagingService { private static final String TAG = \"MyFirebaseMsgService\"; Map&lt;String, String&gt; messageBody; @Override public void onMessageReceived(RemoteMessage remoteMessage) { if (remoteMessage.getData().size() &gt; 0) { Log.d(TAG, \"Message data payload: \" + remoteMessage.getData()); messageBody = remoteMessage.getData(); sendNotification(messageBody.get(\"xxx\")); # 这里messageBody类似json格式，messageBody.get(\"xxx\")获得key为xxx的值。 } } private void sendNotification(String messageBody) { Intent intent = new Intent(this, &lt;Activity&gt;.class); # 这里指定用户点击通知后所需打开的activity intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_ONE_SHOT); Uri defaultSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION); NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this, \"default\") .setSmallIcon(R.drawable.ic_stat_ic_notification) .setContentTitle(\"Typing-Proof\") .setContentText(messageBody) .setAutoCancel(true) .setSound(defaultSoundUri) .setContentIntent(pendingIntent); NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); if (notificationManager != null) { notificationManager.notify(0, notificationBuilder.build()); } } 重写 onDeletedMessages 如果应用在连接了 FCM 的特定设备上的待处理消息过多（超过 100 条），或者设备已有一个月以上的时间没有连接 FCM，FCM 可能不会传送消息。 在这些情况下，可能会收到对 FirebaseMessagingService.onDeletedMessages () 的回调。 当应用实例收到此回调时，应该执行与应用服务器的完全同步。 如果在过去 4 周内未向该设备上的应用发送消息，FCM 将不会调用 onDeletedMessages ()。 处理后台应用中的通知消息 当应用位于后台时，Android 会将通知消息转发至系统任务栏。默认情况下，用户点按通知时将打开应用启动器。 这包括同时含有通知和数据有效负载的消息（以及从通知控制台发送的所有消息）。 在这些情况下，通知将传送至设备的系统任务栏，数据有效负载则传送至启动器 Activity 的 intent 的 extras 参数中。","categories":[{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/categories/Android/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/tags/Android/"}]},{"title":"Python Pandas 库基础","slug":"Python-Pandas库基础","date":"2017-10-04T01:19:49.000Z","updated":"2021-09-16T02:56:10.895Z","comments":true,"path":"contents/Python-Pandas库基础.html","link":"","permalink":"https://lxmymjr.github.io/contents/Python-Pandas%E5%BA%93%E5%9F%BA%E7%A1%80.html","excerpt":"Pandas 是 Python 第三方库，提供高性能易用数据类型和分析工具，Pandas 基于 NumPy 实现，常与 NumPy 和 Matplotlib 一同使用。 Reference：【MOOC】Python 数据分析与展示 - 北京理工大学 -【第三周】数据分析之概要 ; 公开课 ;Document;GitHub","text":"Pandas 是 Python 第三方库，提供高性能易用数据类型和分析工具，Pandas 基于 NumPy 实现，常与 NumPy 和 Matplotlib 一同使用。 Reference：【MOOC】Python 数据分析与展示 - 北京理工大学 -【第三周】数据分析之概要 ; 公开课 ;Document;GitHub Pandas 库 一般通过 import pandas as pd 来引用 Pandas 库。 pd 通常为该模块的别名。 与 numpy 的区别： NumPy Pandas 基础数据类型 扩展数据类型 关注数据的结构表达 关注数据的应用表达 维度：数据间关系 数据与索引的关系 该库基于 numpy 提供了两个新的数据类型：Series, DataFrame。 基于上述数据类型有各类操作：基本操作、运算操作、特征类操作、关联类操作。 Series 类型（一维） Series 类型由一组数据及与之相关的数据索引组成： index_0 ------&gt; data_a index_1 ------&gt; data_b index_2 ------&gt; data_c index_3 ------&gt; data_d index_4 ------&gt; data_e 索引 数据 Series 是一维带 “标签” 数组 (Series 类型包括 index 和 values 两部分，index 和 values 一一对应) Series 类型的创建 Series 类型可以由如下类型创建： - Python 列表，index 与列表元素个数一致 - 标量值，index 表达 Series 类型的尺寸 - Python 字典，键值对中的 “键” 是索引，index 从字典中进行选择操作 - ndarray，索引和数据都可以通过 ndarray 类型创建 - 其他函数，range () 函数等 列表 12345678910import pandas as pds = pd.Series([1,2,3,4,5])&gt;&gt;&gt;0 1&gt;&gt;&gt;1 2&gt;&gt;&gt;2 3&gt;&gt;&gt;3 4&gt;&gt;&gt;4 5&gt;&gt;&gt;dtype: int64# 第一列为自动索引，dtype后为数据类型。 Pandas 也可以自定义索引。 12345678910import pandas as pds = pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])&gt;&gt;&gt;a 1&gt;&gt;&gt;b 2&gt;&gt;&gt;c 3&gt;&gt;&gt;d 4&gt;&gt;&gt;e 5&gt;&gt;&gt;dtype: int64# 第一列为给定索引，dtype后为数据类型。 标量 12345678910import pandas as pds = pd.Series(5, index=['a', 'b', 'c', 'd', 'e'])&gt;&gt;&gt;a 5&gt;&gt;&gt;b 5&gt;&gt;&gt;c 5&gt;&gt;&gt;d 5&gt;&gt;&gt;e 5&gt;&gt;&gt;dtype: int64# 第一列为给定索引，dtype后为数据类型。 注意：此时不能省略 index。 字典 12345678910import pandas as pds = pd.Series({'a':1, 'b':2, 'c':3, 'd':4, 'e':5}, index=['e', 'd', 'c', 'b', 'a'])&gt;&gt;&gt;e 5&gt;&gt;&gt;d 4&gt;&gt;&gt;c 3&gt;&gt;&gt;b 2&gt;&gt;&gt;a 1&gt;&gt;&gt;dtype: int64# 第一列为给定索引，dtype后为数据类型。 注意，index 里面的值的个数可以少于给定字典的键的个数，但是 index 里面每个值必须都是给定字典的键。输出顺序为 index 的顺序。 ndarray 1234567891011import pandas as pdimport numpy as nps = pd.Series(np.arange(5), index=np.arange(9,4,-1))&gt;&gt;&gt;9 0&gt;&gt;&gt;8 1&gt;&gt;&gt;7 2&gt;&gt;&gt;6 3&gt;&gt;&gt;5 4&gt;&gt;&gt;dtype: int64# 第一列为给定索引，dtype后为数据类型。 注意：这里数据类型为 int64。 range() 12345678910import pandas as pds = pd.Series(range(5), index=range(9,4,-1))&gt;&gt;&gt;9 0&gt;&gt;&gt;8 1&gt;&gt;&gt;7 2&gt;&gt;&gt;6 3&gt;&gt;&gt;5 4&gt;&gt;&gt;dtype: int64# 第一列为给定索引，dtype后为数据类型。 注意：这里数据类型为 int64。 Series 类型的基本操作 获取所有索引、所有数据 1234567891011import pandas as pds = pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])s.index&gt;&gt;&gt;Index([u'a', u'b', u'c', u'd', u'e'], dtype='object')s.values&gt;&gt;&gt;[1 2 3 4 5]type(s.values)&gt;&gt;&gt;&lt;type 'numpy.ndarray'&gt; 注意 a.values 返回的是 ndarray 类型。 索引 自动索引和自定义索引并存（但不能混合使用） 12345678910111213141516171819202122232425262728293031import pandas as pds = pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])s[0]&gt;&gt;&gt;1s['a']&gt;&gt;&gt;1s.at['a']&gt;&gt;&gt;1s.iat[0]&gt;&gt;&gt;1s[[1,2,3]]&gt;&gt;&gt;b 2&gt;&gt;&gt;c 3&gt;&gt;&gt;d 4&gt;&gt;&gt;dtype: int64s[['a','b','c']]&gt;&gt;&gt;a 1&gt;&gt;&gt;b 2&gt;&gt;&gt;c 3&gt;&gt;&gt;dtype: int64s[['a',1]] # 自动索引和自定义索引不能混用。&gt;&gt;&gt;a 1.0&gt;&gt;&gt;1 NaN&gt;&gt;&gt;dtype: float64 切片 NumPy 中运算和操作可用于 Series 类型（运算和操作结果仍然是 Series 类型） 可以通过自定义索引的列表进行切片（切片后的结果仍然是 Series 类型） 可以通过自动索引进行切片，如果存在自定义索引，则一同被切片（切片后的结果仍然是 Series 类型） 12345678910111213141516171819202122232425262728293031323334353637import pandas as pdimport numpy as nps = pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])s[3]&gt;&gt;&gt;4s.loc['b': 'd']&gt;&gt;&gt;b 2&gt;&gt;&gt;c 3&gt;&gt;&gt;d 4&gt;&gt;&gt;dtype: int64s.iloc[1:4]&gt;&gt;&gt;b 2&gt;&gt;&gt;c 3&gt;&gt;&gt;d 4&gt;&gt;&gt;dtype: int64s[:3]&gt;&gt;&gt;a 1&gt;&gt;&gt;b 2&gt;&gt;&gt;c 3&gt;&gt;&gt;dtype: int64s[s &gt; s.median()]&gt;&gt;&gt;d 4&gt;&gt;&gt;e 5&gt;&gt;&gt;dtype: int64np.exp(s)&gt;&gt;&gt;a 2.718282&gt;&gt;&gt;b 7.389056&gt;&gt;&gt;c 20.085537&gt;&gt;&gt;d 54.598150&gt;&gt;&gt;e 148.413159&gt;&gt;&gt;dtype: float64 字典 Python 字典中运算和操作可用于 Series 类型（运算和操作结果仍然是 Series 类型） 通过自定义索引访问 保留字 in 操作（只会判断自定义索引，不会判断自动索引） 使用.get () 方法 1234567891011121314151617import pandas as pds = pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])'c' in s&gt;&gt;&gt;True3 in s&gt;&gt;&gt;Falses.get('c')&gt;&gt;&gt;3s.get('f')&gt;&gt;&gt;Nones.get('f', 100)&gt;&gt;&gt;100 注意s.get(key)： - 如果key存在于索引中，则返回该索引对应的值。 - 如果key不存在于索引中，则返回None。 - 如果get函数中有第二个参数且key不存在于索引中，则返回第二个参数的值，但不会改变s的值。 对齐 Series 类型在运算中会自动对齐不同索引的数据。 1234567891011import pandas as pds1 = pd.Series([1,2,3], index=['a', 'b', 'c'])s2 = pd.Series([3,4,5], index=['c', 'd', 'e'])s1 + s2&gt;&gt;&gt;a NaN&gt;&gt;&gt;b NaN&gt;&gt;&gt;c 6.0&gt;&gt;&gt;d NaN&gt;&gt;&gt;e NaN&gt;&gt;&gt;dtype: float64 名字 Series 对象和索引都可以有一个名字，存储在属性.name 中。 1234567891011import pandas as pds = pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])s.name = 'values's.index.name = 'indexes'&gt;&gt;&gt;indexes&gt;&gt;&gt;a 1&gt;&gt;&gt;b 2&gt;&gt;&gt;c 3&gt;&gt;&gt;d 4&gt;&gt;&gt;e 5&gt;&gt;&gt;Name: values, dtype: int64 修改 Series 对象可以随时修改并即刻生效。 123456789import pandas as pds = pd.Series([1,2,3,4,5], index=['a', 'b', 'c', 'd', 'e'])s['c'] = 30&gt;&gt;&gt;a 1&gt;&gt;&gt;b 2&gt;&gt;&gt;c 30&gt;&gt;&gt;d 4&gt;&gt;&gt;e 5&gt;&gt;&gt;dtype: int64 DataFrame 类型（二维） DataFrame 类型由共用相同索引的一组列组成： column axis=1 index_0 ------&gt; data_a data_f ... data_v index_1 ------&gt; data_b data_g ... data_w rows index_2 ------&gt; data_c data_h ... data_x axis=0 index_3 ------&gt; data_d data_i ... data_y index_4 ------&gt; data_e data_j ... data_z 索引 数据 DataFrame 是一个表格型的数据类型，每列值类型可以不同 (类似于 Excel)。 DataFrame 既有行索引、也有列索引。 DataFrame 常用于表达二维数据，但可以表达多维数据。 DataFrame 类型的创建 DataFrame 类型可以由如下类型创建： - 二维 ndarray 对象 - 由一维 ndarray、列表、字典、元组或 Series 构成的字典 - Series 类型 - 其他 DataFrame 类型 二维 ndarray 12345678910import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5,2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9 字典 12345678910111213141516171819202122232425import pandas as pdimport numpy as npdf_dict = {'one': np.arange(0,10,2), 'two': np.arange(1,10,2)}df = pd.DataFrame(df_dict, index=['a', 'b', 'c', 'd', 'e'])df_dict = {'one': [0,2,4,6,8], 'two': [1,3,5,7,9]}df = pd.DataFrame(df_dict, index=['a', 'b', 'c', 'd', 'e'])df_dict = {'one': {'a':0, 'b':2, 'c':4, 'd':6, 'e':8}, 'two': {'a':1, 'b':3, 'c':5, 'd':7, 'e':9}}df = pd.DataFrame(df_dict)df_dict = {'one': (0,2,4,6,8), 'two': (1,3,5,7,9)}df = pd.DataFrame(df_dict, index=['a', 'b', 'c', 'd', 'e'])df_dict = {'one': pd.Series(range(0,10,2), index=['a', 'b', 'c', 'd', 'e']), 'two': pd.Series(range(1,10,2), index=['a', 'b', 'c', 'd', 'e'])}df = pd.DataFrame(df_dict)# 上述所有的创建方式的结果都一样&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9 字典内的值可以是 ndarray、列表、字典、元组或 Series 类型。 Series 类型 1234567891011121314import pandas as pds1 = pd.Series([0,1], index=['one', 'two'])s2 = pd.Series([2,3], index=['one', 'two'])s3 = pd.Series([4,5], index=['one', 'two'])s4 = pd.Series([6,7], index=['one', 'two'])s5 = pd.Series([8,9], index=['one', 'two'])df = pd.DataFrame([s1,s2,s3,s4,s5], index=['a','b','c','d','e'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9 注意：这里每一个 Series 对象的 index 必须一样，否则报错。 其他 DataFrame 类型 12345678910111213141516import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5,2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df = pd.DataFrame(a, index=['a','b','c'], columns=['one'])&gt;&gt;&gt; one&gt;&gt;&gt;a 0&gt;&gt;&gt;b 2&gt;&gt;&gt;c 4 类似对 DataFrame 进行切片。 读取 CSV 文件 123456789df = pd.read_csv('aaa.csv') # 读取aaa.csv文件df = pd.read_csv('aaa.csv', index_col='bbb') # 指定行标签 labeldf = pd.read_csv(StringIO('one,two\\n0,1\\n2,3\\n4,5\\n6,7\\n8,9')) # 读取csv格式的字符串&gt;&gt;&gt; one two&gt;&gt;&gt;0 0 1&gt;&gt;&gt;1 2 3&gt;&gt;&gt;2 4 5&gt;&gt;&gt;3 6 7&gt;&gt;&gt;4 8 9 DataFrame 类型的基本操作 获取所有索引、所有数据 12345678910111213141516import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])df.index&gt;&gt;&gt;Index([u'a', u'b', u'c', u'd', u'e'], dtype='object')df.columns&gt;&gt;&gt;Index([u'one', u'two'], dtype='object')df.values&gt;&gt;&gt;[[0 1]&gt;&gt;&gt; [2 3]&gt;&gt;&gt; [4 5]&gt;&gt;&gt; [6 7]&gt;&gt;&gt; [8 9]] 索引 1234567891011121314151617181920212223242526272829303132333435363738394041424344import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])df[['one']] # 返回一个DataFrame类型&gt;&gt;&gt; one&gt;&gt;&gt;a 0&gt;&gt;&gt;b 2&gt;&gt;&gt;c 4&gt;&gt;&gt;d 6&gt;&gt;&gt;e 8df['one'] # 返回一个Series类型，注意这里不能用自动索引&gt;&gt;&gt;a 0&gt;&gt;&gt;b 2&gt;&gt;&gt;c 4&gt;&gt;&gt;d 6&gt;&gt;&gt;e 8&gt;&gt;&gt;Name: one, dtype: int32df.loc['c'] # 返回一个Series类型，注意这里不能用自动索引&gt;&gt;&gt;one 4&gt;&gt;&gt;two 5&gt;&gt;&gt;Name: c, dtype: int32 df.iloc[1] # 返回第二行，Series类型，不可直接用a[1]&gt;&gt;&gt;one 2&gt;&gt;&gt;two 3&gt;&gt;&gt;Name: b, dtype: int32df['one']['c'] # 返回一个numpy.int32类型，注意这里顺序为先列后行&gt;&gt;&gt;4df.loc['c', 'one'] # 返回一个numpy.int32类型，注意这里顺序为先行后列&gt;&gt;&gt;4df.at['c', 'one'] # 返回一个numpy.int32类型，注意这里顺序为先行后列&gt;&gt;&gt;4df.iloc[1, 0] # 返回一个numpy.int32类型，注意这里顺序为先行后列&gt;&gt;&gt;4df.iat[2, 0] # 返回一个numpy.int32类型，注意这里顺序为先行后列&gt;&gt;&gt;4 切片 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])df[0:3] # 返回前三行&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5df.head(3) # 返回前三行&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5df.head(-3) # 返回前两行&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3df.take([0, 1, 2]) # 返回第一、二、三行&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5df.take([0], axis=1) # 返回第一列&gt;&gt;&gt; one&gt;&gt;&gt;a 0&gt;&gt;&gt;b 2&gt;&gt;&gt;c 4&gt;&gt;&gt;d 6&gt;&gt;&gt;e 8df.take([-1, -2]) # 返回倒数第一、二行&gt;&gt;&gt; one two&gt;&gt;&gt;e 8 9&gt;&gt;&gt;d 6 7df.tail(2) # 返回倒数两行，注意和上方顺序不一样&gt;&gt;&gt; one two&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df.tail(-2) # 返回倒数三行&gt;&gt;&gt; one two&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df.loc['b':'d'] # 与切片不同，这种情况下包含开头也包含结束&gt;&gt;&gt; one two&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7df.loc['c':, ['one']] # 行标签从c到最后行，且只选取one这一列&gt;&gt;&gt; one&gt;&gt;&gt;c 4&gt;&gt;&gt;d 6&gt;&gt;&gt;e 8df[df &gt; df.median()]&gt;&gt;&gt; one two&gt;&gt;&gt;a NaN NaN&gt;&gt;&gt;b NaN NaN&gt;&gt;&gt;c NaN NaN&gt;&gt;&gt;d 6.0 7.0&gt;&gt;&gt;e 8.0 9.0np.exp(df)&gt;&gt;&gt; one two&gt;&gt;&gt;a 1.000000 2.718282&gt;&gt;&gt;b 7.389056 20.085537&gt;&gt;&gt;c 54.598150 148.413159&gt;&gt;&gt;d 403.428793 1096.633158&gt;&gt;&gt;e 2980.957987 8103.083928 条件筛选 简单逻辑判断（&lt;,&gt;, ==, &amp;, |, ~ 等） 12345678910111213141516171819202122232425262728293031323334353637383940414243import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])df.loc[df['one'] &gt; 5] # one属性大于5的记录df[df['one'] &gt; 5]&gt;&gt;&gt; one two&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df['two'][df['one'] &gt; 5] # 返回Series类型&gt;&gt;&gt;d 7&gt;&gt;&gt;e 9&gt;&gt;&gt;Name: two, dtype: int32df.loc[['two']][df['one'] &gt; 5] # 返回DataFrame类型&gt;&gt;&gt; two&gt;&gt;&gt;d 7&gt;&gt;&gt;e 9df.loc[:, ['two','one']][df['one'] &gt; 5] # 调换index顺序df[['two','one']][df['one'] &gt; 5]&gt;&gt;&gt; two one&gt;&gt;&gt;d 7 6&gt;&gt;&gt;e 9 8df.loc[(df['one'] &gt; 5) | (df['two'] &lt;5)] # one属性大于5或者two属性小于5的记录，注意每个判断表达式都要用括号括起来df[(df['one'] &gt; 5) | (df['two'] &lt;5)]&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df.loc[df['two'] != 5] # 删除某符合条件的行df[df['two'] != 5]df.drop(df.loc[df.two == 5].index, axis=0)df.drop(df[df.two == 5].index, axis=0)&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9 自定义函数筛选 12345678910111213141516171819202122232425262728293031import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])df.loc[lambda x: x['one'] * x['two'] &gt; 5] # 函数入参x是整个DataFrame&gt;&gt;&gt; one two&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df[df.apply(lambda x: x['one'] * x['two'] &gt; 5, axis=1)] # 函数入参x是一行数据Series&gt;&gt;&gt; one two&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9def filter(x): try: return x &gt; 5 except: return Falsedf[df.apply(filter, axis=1)] # 函数作为apply的参数&gt;&gt;&gt; one two&gt;&gt;&gt;a NaN NaN&gt;&gt;&gt;b NaN NaN&gt;&gt;&gt;c NaN NaN&gt;&gt;&gt;d 6.0 7.0&gt;&gt;&gt;e 8.0 9.0 字典 in 关键字只能检查 columns 的值是否存在。 get 关键字也只能提取列 1234567891011121314151617181920import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])'c' in df&gt;&gt;&gt;False'one' in df&gt;&gt;&gt;Truedf.get('c')&gt;&gt;&gt;Nonedf.get('one')&gt;&gt;&gt;a 0&gt;&gt;&gt;b 2&gt;&gt;&gt;c 4&gt;&gt;&gt;d 6&gt;&gt;&gt;e 8&gt;&gt;&gt;Name: one, dtype: int32 对齐 12345678910111213141516171819202122import pandas as pdimport numpy as npdf1 = pd.DataFrame(np.arange(6).reshape(3, 2), index=['a','b','c'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5df2 = pd.DataFrame(np.arange(4, 10).reshape(3, 2), index=['c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df1 + df2&gt;&gt;&gt; one two&gt;&gt;&gt;a NaN NaN&gt;&gt;&gt;b NaN NaN&gt;&gt;&gt;c 8.0 10.0&gt;&gt;&gt;d NaN NaN&gt;&gt;&gt;e NaN NaN 名字 12345678910111213import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])df.columns.name = 'columns'df.index.name = 'indexes'&gt;&gt;&gt;columns one two&gt;&gt;&gt;indexes &gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9 修改 123456789101112131415161718192021222324252627282930import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])s = {8,6,4,2,0}&gt;&gt;&gt;set([0, 8, 2, 4, 6])df['one'] = {8,6,4,2,0}&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 8 3&gt;&gt;&gt;c 2 5&gt;&gt;&gt;d 4 7&gt;&gt;&gt;e 6 9df['one'] = [8,6,4,2,0]&gt;&gt;&gt; one two&gt;&gt;&gt;a 8 1&gt;&gt;&gt;b 6 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 2 7&gt;&gt;&gt;e 0 9df['one'] = (8,6,4,2,0)&gt;&gt;&gt; one two&gt;&gt;&gt;a 8 1&gt;&gt;&gt;b 6 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 2 7&gt;&gt;&gt;e 0 9 字典会自动重排顺序。 Pandas 的数据类型操作 Pandas 提供各种函数对 Series 类型和 DataFrame 类型进行操作，两种类型操作类似，下面例子以 DataFrame 为例。 重新索引 .reindex () 能够改变或重排 Series 和 DataFrame 索引 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df.reindex(index=['e','d','c','b','a'])&gt;&gt;&gt; one two&gt;&gt;&gt;e 8 9&gt;&gt;&gt;d 6 7&gt;&gt;&gt;c 4 5&gt;&gt;&gt;b 2 3&gt;&gt;&gt;a 0 1df.reindex(columns=['two','one','three']) # 注意仅仅是重排索引，如果列名不存在，整列为NaN&gt;&gt;&gt; two one three&gt;&gt;&gt;a 1 0 NaN&gt;&gt;&gt;b 3 2 NaN&gt;&gt;&gt;c 5 4 NaN&gt;&gt;&gt;d 7 6 NaN&gt;&gt;&gt;e 9 8 NaNdf.set_index('one') # 将某列变成索引&gt;&gt;&gt; two&gt;&gt;&gt;one &gt;&gt;&gt;0 1&gt;&gt;&gt;2 3&gt;&gt;&gt;4 5&gt;&gt;&gt;6 7&gt;&gt;&gt;8 9df.reset_index() # 新生成数字升序索引，原索引变成新的列&gt;&gt;&gt; index one two&gt;&gt;&gt;0 a 0 1&gt;&gt;&gt;1 b 2 3&gt;&gt;&gt;2 c 4 5&gt;&gt;&gt;3 d 6 7&gt;&gt;&gt;4 e 8 9df.reset_index(drop=True) # 新生成数字升序索引，原索引丢弃&gt;&gt;&gt; one two&gt;&gt;&gt;0 0 1&gt;&gt;&gt;1 2 3&gt;&gt;&gt;2 4 5&gt;&gt;&gt;3 6 7&gt;&gt;&gt;4 8 9df.rename(columns={'one': 'x', 'two': 'y'}) # 列索引重命名&gt;&gt;&gt; x y&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df.rename({'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}) # 行索引重命名&gt;&gt;&gt; one two&gt;&gt;&gt;1 0 1&gt;&gt;&gt;2 2 3&gt;&gt;&gt;3 4 5&gt;&gt;&gt;4 6 7&gt;&gt;&gt;5 8 9df.rename(str.upper) # 行索引更改种类；如需要改变列索引种类则增加参数axis='columns'&gt;&gt;&gt; one two&gt;&gt;&gt;A 0 1&gt;&gt;&gt;B 2 3&gt;&gt;&gt;C 4 5&gt;&gt;&gt;D 6 7&gt;&gt;&gt;E 8 9 插入 123456789101112131415161718192021222324252627282930313233import pandas as pdimport numpy as npdf1 = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df2 = df1.columns.insert(1, 'three')&gt;&gt;&gt;Index([u'one', u'three', u'two'], dtype='object')df3 = df1.reindex(columns=df2, fill_value=5)&gt;&gt;&gt; one three two&gt;&gt;&gt;a 0 5 1&gt;&gt;&gt;b 2 5 3&gt;&gt;&gt;c 4 5 5&gt;&gt;&gt;d 6 5 7&gt;&gt;&gt;e 8 5 9df4 = df1.index.insert(3, 'f')&gt;&gt;&gt;Index([u'a', u'b', u'c', u'f', u'd', u'e'], dtype='object')df5 = df1.reindex(index=df4, fill_value=5)&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;f 5 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9 合并 合并官方教程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import pandas as pdimport numpy as npdf1 = pd.DataFrame(np.arange(10).reshape(5, 2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df2 = pd.DataFrame(np.arange(10, 16).reshape(3, 2), index=['f','g','h'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;f 10 11&gt;&gt;&gt;g 12 13&gt;&gt;&gt;h 14 15df3 = pd.DataFrame(np.arange(16, 22).reshape(3, 2), index=['i','j','k'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;i 16 17&gt;&gt;&gt;j 18 19&gt;&gt;&gt;k 20 21df4 = pd.DataFrame(np.arange(10, 25).reshape(5, 3), index=['a','b','c','d','e'], columns=['three', 'four', 'five'])&gt;&gt;&gt; three four five&gt;&gt;&gt;a 10 11 12&gt;&gt;&gt;b 13 14 15&gt;&gt;&gt;c 16 17 18&gt;&gt;&gt;d 19 20 21&gt;&gt;&gt;e 22 23 24df5 = pd.concat([df1, df2, df3], keys=['x', 'y', 'z']) # 行合并&gt;&gt;&gt; one two&gt;&gt;&gt;x a 0 1&gt;&gt;&gt; b 2 3&gt;&gt;&gt; c 4 5&gt;&gt;&gt; d 6 7&gt;&gt;&gt; e 8 9&gt;&gt;&gt;y f 10 11&gt;&gt;&gt; g 12 13&gt;&gt;&gt; h 14 15&gt;&gt;&gt;z i 16 17&gt;&gt;&gt; j 18 19&gt;&gt;&gt; k 20 21df5.loc['y']&gt;&gt;&gt; one two&gt;&gt;&gt;f 10 11&gt;&gt;&gt;g 12 13&gt;&gt;&gt;h 14 15df5.loc['y'].loc['g']&gt;&gt;&gt;one 12&gt;&gt;&gt;two 13&gt;&gt;&gt;Name: g, dtype: int32 pd.concat([df1, df4], axis=1) # 列合并&gt;&gt;&gt; one two three four five&gt;&gt;&gt;a 0 1 10 11 12&gt;&gt;&gt;b 2 3 13 14 15&gt;&gt;&gt;c 4 5 16 17 18&gt;&gt;&gt;d 6 7 19 20 21&gt;&gt;&gt;e 8 9 22 23 24df6 = pd.DataFrame(np.arange(10, 16).reshape(3, 2), index=['d','e','f'], columns=['two', 'three'])&gt;&gt;&gt; two three&gt;&gt;&gt;d 10 11&gt;&gt;&gt;e 12 13&gt;&gt;&gt;f 14 15pd.concat([df1, df6], axis=1) # 列合并，行并集&gt;&gt;&gt; one two two three&gt;&gt;&gt;a 0.0 1.0 NaN NaN&gt;&gt;&gt;b 2.0 3.0 NaN NaN&gt;&gt;&gt;c 4.0 5.0 NaN NaN&gt;&gt;&gt;d 6.0 7.0 10.0 11.0&gt;&gt;&gt;e 8.0 9.0 12.0 13.0&gt;&gt;&gt;f NaN NaN 14.0 15.0pd.concat([df1, df6], axis=1, join='inner') # 列合并，行交集&gt;&gt;&gt; one two two three&gt;&gt;&gt;d 6 7 10 11&gt;&gt;&gt;e 8 9 12 13df1.append(df2) # 行合并 one twoa 0 1b 2 3c 4 5d 6 7e 8 9f 10 11g 12 13h 14 15df1.append([df2, df3]) # 多个DataFrame行合并 one twoa 0 1b 2 3c 4 5d 6 7e 8 9f 10 11g 12 13h 14 15i 16 17j 18 19k 20 21df1.append(df6) # 行合并，列交集 one two threea 0.0 1 NaNb 2.0 3 NaNc 4.0 5 NaNd 6.0 7 NaNe 8.0 9 NaNd NaN 10 11.0e NaN 12 13.0f NaN 14 15.0df1.append(df6, ignore_index=True) # 行合并，列交集，重新索引 one two three0 0.0 1 NaN1 2.0 3 NaN2 4.0 5 NaN3 6.0 7 NaN4 8.0 9 NaN5 NaN 10 11.06 NaN 12 13.07 NaN 14 15.0 索引 Series 和 DataFrame 的索引是 Index 类型，Index 对象是不可修改类型 Index 类型的常用方法： 方法 说明 idx.append(idx) 连接另一个 Index 对象，产生新的 Index 对象 idx.diff(idx) 计算差集，产生新的 Index 对象 idx.intersection(idx) 计算交集，产生新的 Index 对象 idx.union(idx) 计算并集，产生新的 Index 对象 idx.delete(loc) 删除 loc 位置处的元素，产生新的 Index 对象 idx.insert(loc, e) 在 loc 位置处增加一个元素 e，产生新的 Index 对象 Series/DataFrame.drop(idx.vaule, axis=0/1) 删除 Series 和 DataFrame 指定行或列索引，axis=1 表示列（默认 axis=0） 数据类型运算 算术运算法则 算术运算根据行列索引，补齐后运算，运算默认产生浮点数。 补齐时缺项填充 NaN (空值)。 二维和一维、一维和零维间为广播运算（低维对象元素会作用到高维对象的每一个元素）。 采用 +、‐、*、/ 符号进行的二元运算产生新的对象。 方法形式的运算可通过指定参数避免上面的 NaN 的产生。 方法 说明 .add(d, **argws) 类型间的加法运算，可选参数 .sub(d, **argws) 类型间的减法运算，可选参数 .mul(d, **argws) 类型间的乘法运算，可选参数 .div(d, **argws) 类型间的除法运算，可选参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import pandas as pdimport numpy as npdf1 = pd.DataFrame(np.arange(3).reshape(3,1), index=['a','b','c'], columns=['one'])&gt;&gt;&gt; one&gt;&gt;&gt;a 0&gt;&gt;&gt;b 1&gt;&gt;&gt;c 2df2 = pd.DataFrame(np.arange(10).reshape(5,2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df1 + df2&gt;&gt;&gt; one two&gt;&gt;&gt;a 0.0 NaN&gt;&gt;&gt;b 3.0 NaN&gt;&gt;&gt;c 6.0 NaN&gt;&gt;&gt;d NaN NaN&gt;&gt;&gt;e NaN NaNdf1.add(df2, fill_value=5) # 先填充后运算&gt;&gt;&gt; one two&gt;&gt;&gt;a 0.0 6.0&gt;&gt;&gt;b 3.0 8.0&gt;&gt;&gt;c 6.0 10.0&gt;&gt;&gt;d 11.0 12.0&gt;&gt;&gt;e 13.0 14.0df3 = pd.Series([5, 10], index=['one', 'two'])&gt;&gt;&gt;one 5&gt;&gt;&gt;two 10&gt;&gt;&gt;dtype: int32df3 + 5 # 广播运算&gt;&gt;&gt;one 10&gt;&gt;&gt;two 15&gt;&gt;&gt;dtype: int32df2 + df3 # 不同维度间的广播运算，一维Series默认在轴1参与运算&gt;&gt;&gt; one two&gt;&gt;&gt;a 5 11&gt;&gt;&gt;b 7 13&gt;&gt;&gt;c 9 15&gt;&gt;&gt;d 11 17&gt;&gt;&gt;e 13 19df3 = pd.Series([5, 10, 15], index=['a', 'b', 'c'])&gt;&gt;&gt;a 5&gt;&gt;&gt;b 10&gt;&gt;&gt;c 15&gt;&gt;&gt;dtype: int32df2.add(df3, axis=0) # 使用运算方法可以令一维Series在轴0参与运算&gt;&gt;&gt; one two&gt;&gt;&gt;a 5.0 6.0&gt;&gt;&gt;b 12.0 13.0&gt;&gt;&gt;c 19.0 20.0&gt;&gt;&gt;d NaN NaN&gt;&gt;&gt;e NaN NaN 比较运算法则 比较运算只能比较相同索引的元素，不进行补齐。 二维和一维、一维和零维间为广播运算。 采用 &gt;、&lt;、&gt;=、&lt;=、==、!= 等符号进行的二元运算产生布尔对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import pandas as pdimport numpy as npdf1 = pd.DataFrame(np.arange(15,5,-1).reshape(5,2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 15 14&gt;&gt;&gt;b 13 12&gt;&gt;&gt;c 11 10&gt;&gt;&gt;d 9 8&gt;&gt;&gt;e 7 6df2 = pd.DataFrame(np.arange(10).reshape(5,2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df1 &gt; df2 #df1和df2必须尺寸一样&gt;&gt;&gt; one two&gt;&gt;&gt;a True True&gt;&gt;&gt;b True True&gt;&gt;&gt;c True True&gt;&gt;&gt;d True True&gt;&gt;&gt;e False Falsedf3 = pd.Series([5,10,15], index=['a', 'b', 'c'])&gt;&gt;&gt;one 5&gt;&gt;&gt;two 10&gt;&gt;&gt;dtype: int32df3 &gt; 5&gt;&gt;&gt;one False&gt;&gt;&gt;two True&gt;&gt;&gt;dtype: booldf3 &gt; df2 # 不同维度间的广播运算，一维Series默认在轴1参与运算&gt;&gt;&gt; one two&gt;&gt;&gt;a True True&gt;&gt;&gt;b True True&gt;&gt;&gt;c True True&gt;&gt;&gt;d False True&gt;&gt;&gt;e False True 单列 / 多列 / 分组 / 聚合运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5,2), index=['a','b','c','d','e'], columns=['one', 'two'])&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 4 5&gt;&gt;&gt;d 6 7&gt;&gt;&gt;e 8 9df.loc[:, 'one'] = df.loc[:, 'one'].map(lambda x: x ** 2) # 在Pandas中，DataFrame的一列就是一个Series, 可以通过map来对一列进行操作&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 4 3&gt;&gt;&gt;c 16 5&gt;&gt;&gt;d 36 7&gt;&gt;&gt;e 64 9def square(x): return x ** 2df.loc[:, 'one'] = df.loc[:, 'one'].map(square) # 其中lambda函数中的x代表当前元素。可以使用另外的函数来代替lambda函数&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 4 3&gt;&gt;&gt;c 16 5&gt;&gt;&gt;d 36 7&gt;&gt;&gt;e 64 9df.loc[:, 'one'] = df.loc[:, 'one'].map(lambda x: True if x &gt;= 5 else False) # lambda中可以传入任何表达式df.loc[:, 'two'] = df.loc[:, 'two'].map(lambda x: True if x &gt;= 5 else False)&gt;&gt;&gt; one two&gt;&gt;&gt;a False False&gt;&gt;&gt;b False False&gt;&gt;&gt;c False True&gt;&gt;&gt;d True True&gt;&gt;&gt;e True Truedf.loc[:, 'three'] = df.apply(lambda x: x['one'] + 2 * x['two'], axis=1) # 要对DataFrame的多个列同时进行运算，可以使用apply&gt;&gt;&gt; one two three&gt;&gt;&gt;a 0 1 2&gt;&gt;&gt;b 2 3 8&gt;&gt;&gt;c 4 5 14&gt;&gt;&gt;d 6 7 20&gt;&gt;&gt;e 8 9 26df.loc['f', :] = df.apply(lambda x: x['a'] + 2 * x['b'], axis=0) #对DataFrame的多个行同时进行运算，将axis设为0&gt;&gt;&gt; one two&gt;&gt;&gt;a 0.0 1.0&gt;&gt;&gt;b 2.0 3.0&gt;&gt;&gt;c 4.0 5.0&gt;&gt;&gt;d 6.0 7.0&gt;&gt;&gt;e 8.0 9.0&gt;&gt;&gt;f 4.0 7.0# 要对DataFrame的每个元素同时进行运算，可以使用applymapdf = df.applymap(lambda x: x ** 2 if x &lt;= 5 else x * 2)&gt;&gt;&gt; one two&gt;&gt;&gt;a 0 1&gt;&gt;&gt;b 4 9&gt;&gt;&gt;c 16 25&gt;&gt;&gt;d 12 14&gt;&gt;&gt;e 16 18 Pandas 的数据特征分析 排序 .sort_index(axis=0, ascending=True) 方法在指定轴上根据索引进行排序，默认升序。 Series.sort_values(axis=0, ascending=True)、DataFrame.sort_values(by, axis=0, ascending=True) 方法在指定轴上根据数值进行排序，默认升序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5,2), index=['c','b','a','e','d'], columns=['two', 'one'])&gt;&gt;&gt; two one&gt;&gt;&gt;c 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;a 4 5&gt;&gt;&gt;e 6 7&gt;&gt;&gt;d 8 9df.sort_index() # 根据indexes顺排（首字母顺序）&gt;&gt;&gt; two one&gt;&gt;&gt;a 4 5&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 0 1&gt;&gt;&gt;d 8 9&gt;&gt;&gt;e 6 7df.sort_index(ascending=False) # 根据indexes逆排（首字母顺序）&gt;&gt;&gt; two one&gt;&gt;&gt;e 6 7&gt;&gt;&gt;d 8 9&gt;&gt;&gt;c 0 1&gt;&gt;&gt;b 2 3&gt;&gt;&gt;a 4 5df.sort_index(axis=1) # 根据columns顺排（首字母顺序）&gt;&gt;&gt; one two&gt;&gt;&gt;c 1 0&gt;&gt;&gt;b 3 2&gt;&gt;&gt;a 5 4&gt;&gt;&gt;e 7 6&gt;&gt;&gt;d 9 8df.sort_values('two', ascending=False) # 根据'two'这一列的值重排所有的数据&gt;&gt;&gt; two one&gt;&gt;&gt;d 8 9&gt;&gt;&gt;e 6 7&gt;&gt;&gt;a 4 5&gt;&gt;&gt;b 2 3&gt;&gt;&gt;c 0 1df.sort_values('c', axis=1, ascending=False)&gt;&gt;&gt; one two&gt;&gt;&gt;c 1 0&gt;&gt;&gt;b 3 2&gt;&gt;&gt;a 5 4&gt;&gt;&gt;e 7 6&gt;&gt;&gt;d 9 8 注意：排序时，NaN永远都是在排序结果末尾（不管是升序 还是 降序） 统计 适用于 Series 和 DataFrame 类型数据，基本统计分析 方法 说明 .sum() 计算数据的总和，按 0 轴计算，下同 .count() 非 NaN 值的数量 .mean() .median() 计算数据的算术平均值、算术中位数 .var() .std() 计算数据的方差、标准差 .min() .max() 计算数据的最小值、最大值 .describe() 针对 0 轴（各列）的统计汇总 适用于 Series 类型，基本统计分析 方法 说明 .argmin() .argmax() 计算数据最大值、最小值所在位置的索引位置（自动索引） .idxmin() .idxmax() 计算数据最大值、最小值所在位置的索引位置（自定义索引） 适用于 Series 和 DataFrame 类型，累计计算 方法 说明 .cumsum() 依次给出前 1、2、…、n 个数的和 .cumprod() 依次给出前 1、2、…、n 个数的积 .cummax() 依次给出前 1、2、…、n 个数的最大值 .cummin() 依次给出前 1、2、…、n 个数的最小值 适用于 Series 和 DataFrame 类型，滚动计算（窗口计算） 方法 说明 .rolling(w).sum() 依次计算相邻 w 个元素的和 .rolling(w).mean() 依次计算相邻 w 个元素的算术平均值 .rolling(w).var() 依次计算相邻 w 个元素的方差 .rolling(w).std() 依次计算相邻 w 个元素的标准差 .rolling(w).min() .max() 依次计算相邻 w 个元素的最小值和最大值 适用于 Series 和 DataFrame 类型，相关性分析 方法 说明 .cov() 计算协方差矩阵 .corr() 计算相关系数矩阵，Pearson、Spearman、Kendall 等系数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import pandas as pdimport numpy as npdf = pd.DataFrame(np.arange(10).reshape(5,2), index=['a','b','c','d','e'], columns=['one', 'two'])df['one'] = [1, 1, 1, 2, 2]&gt;&gt;&gt; one two&gt;&gt;&gt;a 1 1&gt;&gt;&gt;b 1 3&gt;&gt;&gt;c 1 5&gt;&gt;&gt;d 2 7&gt;&gt;&gt;e 2 9df.groupby('one')['two'].sum() # 按照列one进行分组对列two进行统计求和，返回Series类型&gt;&gt;&gt;one&gt;&gt;&gt;1 9&gt;&gt;&gt;2 16&gt;&gt;&gt;Name: two, dtype: int32 df.groupby([3, 3, 4, 4, 4]).sum() # 可以指定分组&gt;&gt;&gt; one two&gt;&gt;&gt;3 2 4&gt;&gt;&gt;4 5 21df.groupby('one')['two'].describe() # 按照列one进行分组对列two进行统计计数，返回DataFrame类型&gt;&gt;&gt; count mean std min 25% 50% 75% max&gt;&gt;&gt;one &gt;&gt;&gt;1 3.0 3.0 2.000000 1.0 2.0 3.0 4.0 5.0&gt;&gt;&gt;2 2.0 8.0 1.414214 7.0 7.5 8.0 8.5 9.0df['three'] = df.groupby('one')['two'].transform(lambda x: (x.sum() - x) / x.count()) # 按照列one进行分组对列two进行函数运算&gt;&gt;&gt; one two three&gt;&gt;&gt;a 1 1 2.666667&gt;&gt;&gt;b 1 3 2.000000&gt;&gt;&gt;c 1 5 1.333333&gt;&gt;&gt;d 2 7 4.500000&gt;&gt;&gt;e 2 9 3.500000df.groupby('one').agg(['sum', 'count', 'mean', 'median', 'var', 'std', 'min', 'max', 'first', 'last']) # agg方法将一个函数使用在一个数列上，然后返回一个标量的值。内置函数名需要用引号&gt;&gt;&gt; two &gt;&gt;&gt; sum count mean median var std min max first last&gt;&gt;&gt;one &gt;&gt;&gt;1 9 3 3 3 4 2.000000 1 5 1 5&gt;&gt;&gt;2 16 2 8 8 2 1.414214 7 9 7 9df.agg(['sum', 'count', 'mean', 'median', 'var', 'std', 'min', 'max', 'first', 'last'])&gt;&gt;&gt; one two&gt;&gt;&gt;sum 7.000000 25.000000&gt;&gt;&gt;count 5.000000 5.000000&gt;&gt;&gt;mean 1.400000 5.000000&gt;&gt;&gt;median 1.000000 5.000000&gt;&gt;&gt;var 0.300000 10.000000&gt;&gt;&gt;std 0.547723 3.162278&gt;&gt;&gt;min 1.000000 1.000000&gt;&gt;&gt;max 2.000000 9.000000","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Data Analysis","slug":"Data-Analysis","permalink":"https://lxmymjr.github.io/tags/Data-Analysis/"}]},{"title":"Python Matplotlib 库基础","slug":"Python-Matplotlib库基础","date":"2017-09-26T00:40:10.000Z","updated":"2021-09-16T02:56:10.894Z","comments":true,"path":"contents/Python-Matplotlib库基础.html","link":"","permalink":"https://lxmymjr.github.io/contents/Python-Matplotlib%E5%BA%93%E5%9F%BA%E7%A1%80.html","excerpt":"Matplotlib 是 Python 语言的一个图像绘制库。支持各种可视化类。 Reference：【MOOC】Python 数据分析与展示 - 北京理工大学 -【第二周】数据分析之展示 ; 公开课 ;Document;GitHub","text":"Matplotlib 是 Python 语言的一个图像绘制库。支持各种可视化类。 Reference：【MOOC】Python 数据分析与展示 - 北京理工大学 -【第二周】数据分析之展示 ; 公开课 ;Document;GitHub Matplotlib 库的 pyplot 子库 一般通过 import matplotlib.pyplot as plt 来引用 Matplotlib 库的 pyplot 子库。 plt 通常为该模块的别名。 线形图 matplotlib.pyplot.plot plt.plot() 为常用的画直线、折线或者曲线图像的函数。 最简单的使用 plt.plot(list_x or numpy.array_x)：当 plt.plot 函数只有一个输入列表或者数组时，参数的元素的索引为 X 轴值，参数的元素的值为 Y 轴值。 当有两个输入列表或者数组时 plt.plot(list_x or numpy.array_x, list_y or numpy.array_y)，第一个参数的元素的值为 X 轴值，第二个参数的元素的值为 Y 值。 当绘制多条曲线时，各条图像的 X 轴不能省略。 当有 2n 个输入列表或者数组时（n 为大于 1 的整数），将会绘制 n 条图像，第 i 个参数的元素的值为 X 轴值，第 i+1 个参数的元素的值为 Y 值（i 为 1 到 n 之间的整数）。 一般化的函数格式： plt.plot(x, y, format_string, **kwargs：x 是 X 轴数据，列表或者数组，可选；y 是 Y 轴数据，列表或者数组；format_string 是控制曲线的格式，可选，**kwargs 是第二组或者更多 (x, y, format_string)。 format_string 是控制曲线的格式，由颜色字符、风格字符、标记字符组成。 - 颜色字符： 蓝色 绿色 红色 青绿色 洋红色 黄色 黑色 白色 RGB 某颜色 灰度值 'b' 'g' 'r' 'c' 'm' 'y' 'k' 'w' '#666666' '0.5' 风格字符： 实线 破折线 点划线 虚线 无线条 '-' '--' '-.' ':' '' 或者 ' ' 标记字符： 点标记 像素标记（极小的点） 实心圆标记 上三角标记 下三角标记 右三角标记 左三角标记 '.' ',' 'o' 'v' '^' '&gt;' '&lt;' 下花三角标记 上花三角标记 左花三角标记 右花三角标记 实心方形标记 实心五角标记 星形标记 '1' '2' '3' '4' 's' 'p' '*' 竖六边形标记 横六边形标记 十字标记 叉标记 菱形标记 瘦菱形标记 垂直线标记 'h' 'H' '+' 'x' 'D' 'd' | 举例： 1234567import matplotlib.pyplot as pltimport numpy as npa = np.arange(5)plt.plot(a, a, 'go-', a, a*1.5, 'r1', a, a*2, 'h', a, a*2.5, 'b:d')plt.savefig('example', dpi=500)plt.show() 因为三种格式所用字符均不相同，所以三者可以任意顺序排列，并且可选。 此外也可以通过属性赋值来设定格式： 属性 说明 color 线条颜色 linestyle 线条风格 marker 标记风格 markerfacecolor 标记颜色 markersize 标记尺寸 markevery 标记间隔 markevery 默认为 None, 此时所有点将会被标记。 markevery=N, N 为整数，此时每隔 N-1 个点将会被标记。 markevery=(start, N)，start 和 N 均为整数，此时从第 start 个点开始，每隔 N-1 个点将会被标记。 markevery=slice(start, end, N)，start、end 和 N 均为整数，此时从第 start 个点开始直到第 end-1 个点，每隔 N-1 个点将会被标记。 markevery=[x1, x2, ..., xi]，只有第 x1, x2, ..., xi 个点被标记。这里列表为任意长度（最大长度为数据的总个数）。 markevery=n，n 为浮点数，此时标记的 x 轴坐标将会均匀间隔分布，标记个数为 1/n 取整。 markevery=(start, N)，start 和 N 均为浮点数，此时标记的 x 轴坐标将会均匀间隔分布，标记个数为 (1-start)/n 取整，而且从第 l*start 个点开始，其中 l 为数据总个数。 plt.show() 显示所绘图像；plt.savefig(filename, dpi) 保存所绘图像为文件，默认 PNG 格式，dpi 表示输出质量。 plt.figure(num=None, figsize=None, dpi=None, facecolor=None, clear=False) 定义图像参数，其中 num 表示图像个数；figsize 表示图像尺寸，为一个二维元组；dpi 表示输出质量；facecolor 表示背景颜色；clear=True 表示清空之前的绘制。 pyplot 的子绘图区域 plt.subplot matplotlib.pyplot.subplot plt.subplot(nrows, ncols, plot_number) 在全局绘图区域中创建一个分区体系，并定位到一个子绘图区域。 举例： 注：参数之间的逗号可以省略。 调用 plt.subplot 函数后使用 plt.plot 函数绘图至对应区域。 plt.subplot2grid plt.subplot2grid(GridSpec, CurSpec, colspan=1, rowspan=1) 设定网络，选中网络起始索引，从编号 0 开始，确定选中的行列区域跨越的数量。 举例： 注：为了使上面的 subplot2grid 函数的调用显示更加简洁，可以引入 GridSpec 类来实现该功能 12345678import matplotlib.gridspec as gridspecgs = gridspec.GridSpec(3,3)ax1 = plt.subplot(gs[0,:])ax2 = plt.subplot(gs[1,:-1])ax3 = plt.subplot(gs[0,-1])ax4 = plt.subplot(gs[2,0])ax5 = plt.subplot(gs[2,1]) pyplot 的文字显示 字体属性 中文字体分类： 黑体 楷体 隶书 仿宋 幼圆 宋体 'SimHei' 'Kaiti' 'LiSu' 'FangSong' 'YouYuan' 'STSong' 字体风格： 正常 斜体 'normal' 或者 'roman' 'italic' 或者 'oblique' 字体大小： 字号 极小 很小 小 比父元素更小 中 大 很大 极大 比父元素更大 整数 xx-small x-small small smaller medium large x-large xx-large larger 修改全局的字体属性： 1234import matplotlibmatplotlib.rcParams['font.family']='' #字体matplotlib.rcParams['font.style']='' #风格matplotlib.rcParams['font.size']='' #字号 修改局部的字体属性： 在有文字显示的函数中增加属性 fontname 改变字体，fontstyle 改变风格，fontsize 改变字号 文本显示 函数 说明 plt.xlabel(string) 对 X 轴增加文本标签 plt.ylabel(string) 对 Y 轴增加文本标签 plt.title(string) 对图形整体增加文本标签 plt.text(x, y, string) 在任意位置增加文本标签 plt.annotate(s, xy=arrow_crd, xytext=text_crd, arrowprops=dict) 在图形中增加带箭头的注解 注：文本字符串中可以用一对 $ 符号来引入 LaTeX 公式。 annotate 函数的参数：plt.annotate(s, xy=arrow_crd, xytext=text_crd, arrowprops=dict) s 为文本字符串；xy 为箭头指向的位置，即要注释的位置；xytext 为箭尾的位置，即文本位置；两个位置属性的值均为二维元组；arrowprops 为箭头的属性，如：facecolor 箭头颜色，shrink 箭头缩放成程度，width 箭头线段宽度，headwidth 箭头宽度，frac 箭头头部所占据的比例等；这些属性以字典形式传入。 坐标轴显示 函数 说明 plt.xticks(x, list) 对 X 轴增加坐标标记 plt.yticks(y, list) 对 Y 轴增加坐标标记 plt.xlim(min, max) 显示 X 轴坐标范围 plt.ylim(min, max) 显示 Y 轴坐标范围 其中 ticks 可以设置字体大小（fontsize）、旋转角度（rotation）等属性。 网格显示 plt.grid(Ture) matplotlib 库的基础绘图函数 基础绘图函数 函数 说明 plt.plot(x,y,fmt) 绘制一个坐标图 plt.vlines(x, ymin, ymax) 绘制一个垂直线 plt.hlines(y, xmin, xmax) 绘制一个水平线 plt.axvline(x=0, ymin=0, ymax=1) 绘制一个垂直线 plt.axhline(y=0, xmin=0, xmax=1) 绘制一个水平线 plt.axvspan(xmin, xmax, ymin=0, ymax=1) 绘制一个垂直矩形 plt.axhspan(ymin, ymax, xmin=0, xmax=1) 绘制一个水平矩形 plt.boxplot(data,notch,position) 绘制一个箱形图 plt.bar(left,height,width,bottom) 绘制一个条形图 plt.barh(width,bottom,left,height) 绘制一个横向条形图 plt.hist(x,bins,normed) 绘制一个直方图 plt.pie(data, explode) 绘制一个饼状图 plt.scatter(x,y) 绘制一个散点图 plt.stem(x,y,linefmt,markerfmt) 绘制一个柴火图 plt.step(x,y,where) 绘制一个步阶图 pyplot.psd() 绘制一个能量谱密度图 pyplot.magnitude_spectrum() 绘制一个幅度频谱图 pyplot.phase_spectrum() 绘制一个相角频谱图 pyplot.angle_spectrum() 绘制一个相位频谱图 绘制垂直、水平线、矩形 matplotlib.pyplot.axhline;matplotlib.pyplot.axvline;matplotlib.pyplot.hlines;matplotlib.pyplot.vlines;matplotlib.pyplot.axhspan;matplotlib.pyplot.axvspan 123456789101112131415161718192021import matplotlib.pyplot as plt# draw a default hline at y=1 that spans the xrangeplt.axhline(y=1)# draw a default vline at x=1 that spans the yrangeplt.axvline(x=1)# draw a thick red hline at y=0 that spans the xrangeplt.axhline(linewidth=8, color='#d62728')# draw a thick blue vline at x=0 that spans the yrange from 0.8 to 1.4plt.axvline(x=0.25, ymin=0.6, ymax=0.8, linewidth=8, color='#1f77b4')plt.axvline(x=0.5, ymin=0.8, ymax=0.6, linewidth=8, color='#1f77b4')plt.vlines(x=0.75, ymin=0.8, ymax=1.4, linewidth=8, color='#1f77b4')plt.vlines(x=1, ymin=1.4, ymax=0.8, linewidth=8, color='#1f77b4')# draw a default hline at y=.5 that spans the middle half of the axesplt.axhline(y=0.5, xmin=0.25, xmax=0.75)plt.axhspan(0.25, 0.75, xmin=0.2, xmax=0.7, facecolor='0.5', alpha=0.5)plt.axvspan(1.25, 1.55, ymin=0.2, ymax=0.7, facecolor='#2ca02c', alpha=0.5)plt.axis([-1, 2, -1, 2]) plt.axvline(x=0, ymin=0, ymax=1)、plt.axhline(y=0, xmin=0, xmax=1) 与 plt.vlines(x, ymin, ymax)、plt.hlines(y, xmin, xmax) 类似，但是前者可以不填任何参数，而后者必须指定三个参数。其中第一个参数为线段的x轴或者y轴位置，第二、第三个参数为线段的起点和终点位置。其中对于前者，起点和终点位置是由距离坐标系两端的距离的比例来决定，对于后者，起点和终点位置是由绝对坐标来决定。 例如 plt.axvline(x=0.25, ymin=0.6, ymax=0.8, linewidth=8, color='#1f77b4') 表示线段从(0.25,0.6*(2-(-1))+(-1))到(0.25,0.8*(2-(-1))+(-1))。其中ymin和ymax的值交换位置不影响结果。而 plt.vlines(x=0.75, ymin=0.8, ymax=1.4, linewidth=8, color='#1f77b4') 表示线段从(0.75,0.8)到(0.75,1.4)。同样的，ymin和ymax的值交换位置不影响结果。从图中还可以观察到，axvline形成的线段上下端也有宽度，而vline形成的线段没有，所以前者形成的线段比后者稍长。 除x,y,xmin,xmax,ymin,ymax之外的参数为通用参数，其中facecolor或者fc表示面积颜色，alpha表示透明度（取值为0到1之间的浮点数）。 绘制箱形图、条形图、直方图 箱形图 matplotlib.pyplot.boxplot 123456789101112131415161718192021222324252627import numpy as npimport matplotlib.pyplot as pltnp.random.seed(0)data = np.random.lognormal(size=(25, 4), mean=1.5, sigma=1.75)labels = list('ABCD')fig, axes = plt.subplots(nrows=2, ncols=6, figsize=(12, 6), sharey=True)axes[0, 0].boxplot(data, labels=labels)axes[0, 1].boxplot(data, labels=labels, showmeans=True)axes[0, 2].boxplot(data, labels=labels, showmeans=True, meanline=True)axes[0, 3].boxplot(data, labels=labels, showbox=False, showcaps=False)axes[0, 4].boxplot(data, labels=labels, notch=True, bootstrap=10000)axes[0, 5].boxplot(data, labels=labels, showfliers=False)boxprops = dict(linestyle='--', linewidth=3, color='darkgoldenrod')flierprops = dict(marker='o', markerfacecolor='green', markersize=12, linestyle='none')medianprops = dict(linestyle='-.', linewidth=2.5, color='firebrick')meanpointprops = dict(marker='D', markeredgecolor='black', markerfacecolor='firebrick')meanlineprops = dict(linestyle='--', linewidth=2.5, color='purple')axes[1, 0].boxplot(data, boxprops=boxprops)axes[1, 1].boxplot(data, flierprops=flierprops, medianprops=medianprops)axes[1, 2].boxplot(data, whis='range')axes[1, 3].boxplot(data, meanprops=meanpointprops, meanline=False, showmeans=True)axes[1, 4].boxplot(data, meanprops=meanlineprops, meanline=True, showmeans=True)axes[1, 5].boxplot(data, whis=[15, 85]) data为随机生成的4×25数组，图片划分为2栏6列，sharey=Ture 表示共享Y轴坐标。 axes为坐标系对象是一个2×6的数组，每一个元素对应一个坐标系。 plt.boxplot() 第一个参数为所展示的数据，数组形式；label为X轴坐标的标签。 vert=False 表示箱形图案为横向放置，patch_artist=True 表示箱形图框内有填充。 showmeans=Ture 表示显示平均值，meanline=Ture 表示使平均值以虚线形式显示。 showbox=False 表示不显示箱形边框，showcaps=False 表示不显示上下两端的error_bar。 notch=True 表示显示槽口，bootstrap=10000 表示显示中值周围的置信区间。 showfliers=False 表示不显示上下error_bar之外的值。 boxprops 表示箱形图案的属性；flierprops 表示error_bar之外的点的属性；medianprops 表示中值点的属性；meanprops 表示平均值点的属性。 whis 表示数据范围的属性：它的值可以是浮点数、字符串、数组范围。 - 如果 whis='range' 表示error_bar的范围为所有数值的最小值到所有数值的最大值，即没有上下极端值。 - 如果 whis=[a,b]，其中a,b是两个数字（整型或者浮点型均可），则error_bar的范围为所有数值由小到大排列后第a%位的值到所有数值由小到大排列后第b%位的值。 - 如果 whis=c，其中c是一个浮点数，则表示error_bar的范围为(Q1-c*(Q3-Q1))到(Q3+c*(Q3-Q1))，其中Q1所有数值由小到大排列后第25%的值，Q3所有数值由小到大排列后第75%的值。 - 如果不设置whis，则默认值为 whis=1.5。 条形图 matplotlib.pyplot.bar;matplotlib.pyplot.barh 123456789101112131415161718192021import numpy as npimport matplotlib.pyplot as pltN = 5menMeans = (20, 35, 30, 35, 27)womenMeans = (25, 32, 34, 20, 25)menStd = (2, 3, 4, 1, 2)womenStd = (3, 5, 2, 3, 3)ind = np.arange(N) # the x locations for the groupswidth = 0.5 # the width of the bars: can also be len(x) sequencep1 = plt.bar(ind, menMeans, width, color='r', hatch='o')plt.errorbar(ind+0.25, menMeans, yerr=menStd, capsize=5, elinewidth=5, capthick=5, ecolor='g', linewidth=0)p2 = plt.bar(ind, womenMeans, width, bottom=menMeans, yerr=womenStd)plt.errorbar(ind+0.25, np.array(womenMeans)+np.array(menMeans) , yerr=womenStd, capsize=5, elinewidth=5, capthick=5, ecolor='y', linewidth=0)plt.ylabel('Scores')plt.title('Scores by group and gender')plt.xticks(ind+0.25, ('G1', 'G2', 'G3', 'G4', 'G5'))plt.yticks(np.arange(0, 81, 10))plt.legend((p1[0], p2[0]), ('Men', 'Women')) plt.bar(x, height, width, bottom, align='center') 表示画一个柱状图案（矩形），其上下左右边界分别为bottom+height、bottom、x-width/2、x+width/2 align表示x表示矩形的中间（align='center'）还是矩形的左边边界（align='edge'）。如果需要让x表示矩形的右边边界，则设置align='edge'且width为一个负数。align的默认值为'center'。 其他常用的属性有： color : 柱状图案的填充颜色 edgecolor : 柱状图案的边框颜色 linewidth : 柱状图案的边框粗细 xerr : x轴的error bar yerr : y轴的error bar elinewidth: error bar的宽度 capsize： error bar的帽子大小 capthick： error bar的帽子宽度 ecolor : error bar的颜色 log : 如果为true，则坐标为对数显示 hatch：图案填充， ['/' | '' | '|' | '-' | '+' | 'x' | 'o' | 'O' | '.' | '*'] 如果绘制横向条形图，则使用 plt.barh(y, height, width, left, align='center')，使用方法同上。 直方图 matplotlib.pyplot.hist 12345678910111213141516171819202122232425import numpy as npimport matplotlib.mlab as mlabimport matplotlib.pyplot as pltnp.random.seed(0)# example datamu = 100 # mean of distributionsigma = 25 # standard deviation of distributionx = mu + sigma * np.random.randn(500)num_bins = 50fig, ax = plt.subplots()# the histogram of the datan, bins, patches = ax.hist(x, num_bins, normed=True)for i in patches[::2]: i.set_color('y')# add a 'best fit' liney = mlab.normpdf(bins, mu, sigma)ax.plot(bins, y, '--')ax.set_xlabel('Smarts')ax.set_ylabel('Probability density')ax.set_title(r'Histogram of IQ: $\\mu=100$, $\\sigma=25$') data为随机生成的以mu为均值，以sigma为标准差的正态分布数组，数组长度为500。 所绘制的直方图有50个分组。 plt.bar(x, num_bins, normed=True) 中x为data，num_bins为分组个数，normed为是否归一化。 并且返回n, bins, patches三个数组，n和patches的数组维度均为分组个数，而bins的数组维度为分组个数+1； 其中n为数据落在每个分组中的个数或者概率密度，bins为每个分组的两端的x坐标值，patches表示每个分组，可以通过patches对分组属性进行设置。 当normed=False时，n为数据落在每个分组中的个数；当normed=True，n为数据落在每个分组中的概率密度（注意，不是概率分布，sum(n)*(max(num_bins)-min(num_bins))=num_bins）。 i.set_color('y') 设置了每隔一个分组颜色为黄色。 y = mlab.normpdf(bins, mu, sigma) 返回一个数组，数组为以mu为均值，以sigma为标准差的正态分布曲线上bins所对应的y轴值。 ax.plot(bins, y, '--') 则绘制匹配直方图的正态分布图曲线。 绘制饼状图 matplotlib.pyplot.pie 12345678910import matplotlib.pyplot as plt# Pie chart, where the slices will be ordered and plotted counter-clockwise:labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'sizes = [15, 30, 45, 10]explode = (0, 0.5, 0, 0) # only \"explode\" the 2nd slice (i.e. 'Hogs')fig1, ax1 = plt.subplots()ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', pctdistance=0.5, labeldistance=1.2, radius=2, shadow=True, startangle=90)ax1.axis('equal') # Equal aspect ratio ensures that pie is drawn as a circle. explode表示每部分饼状图案偏离圆心的距离，为绝对距离。 autopct表示显示数字的格式。pctdistance表示显示数字距离圆心的相对距离，默认值为0.6，表示数字离圆心0.6个半径距离。 shadow表示是否有阴影，startangle表示绘制饼状图的起始角度。 labels表示标签，labeldistance表示标签离圆心的相对距离，默认为1.1，表示数字离圆心1.1个半径距离。 radius表示饼状图的半径，为绝对距离。 plt.axis('equal')表示饼状图为正圆形，否则为椭圆形。 绘制散点图 matplotlib.pyplot.scatter 12345678910import numpy as npimport matplotlib.pyplot as pltN = 50x = np.random.rand(N)y = np.random.rand(N)colors = np.random.rand(N)area = np.pi * (15 * np.random.rand(N))**2 # 0 to 15 point radiiplt.scatter(x, y, s=area, c=colors, alpha=0.5) data为50个任意点，颜色也为任意的0-1之间的数，半径为0-15π之间任意的数。 x,y是维度一样的列表，其中每个元素表示每个点的横纵坐标。 s表示大小。alpha表示透明度。 绘制柴火图、步阶图 matplotlib.pyplot.stem；matplotlib.pyplot.step 1234567891011121314151617181920212223import matplotlib.pyplot as pltfrom numpy import maimport numpy as npplt.figure(figsize=(16,4))plt.subplot(1, 2, 1)x = np.linspace(0.1, 2*np.pi, 10)plt.stem(x, np.cos(x), '-.')plt.subplot(1, 2, 2)x = np.arange(1, 7, 0.4)y0 = np.sin(x)y = y0.copy() + 2.5plt.step(x, y, label='pre (default)')y -= 0.5plt.step(x, y, where='mid', label='mid')y -= 0.5plt.step(x, y, where='post', label='post')y = ma.masked_where((y0 &gt; -0.15) &amp; (y0 &lt; 0.15), y - 0.5)plt.step(x, y, label='masked (pre)')plt.legend()plt.xlim(0, 7)plt.ylim(-0.5, 4) x, y表示数据的横纵坐标。 在step函数中有一个where属性，where属性有三个取值'pre'或'post'或'mid'。 where='pre' 是默认值，表示每个步阶的坐标是从(x[i],y[i+1])到(x[i+1],y[i+1])。 where='mid' 表示每个步阶的坐标是从(x[i],y[i])到(x[i+1],y[i])。 where='post' 表示每个步阶的跳跃是从步阶的一半开始。 绘制频谱图 matplotlib.pyplot.psd;matplotlib.pyplot.magnitude_spectrum;matplotlib.pyplot.angle_spectrum;matplotlib.pyplot.phase_spectrum 123456789101112131415161718192021222324252627282930import matplotlib.pyplot as pltimport numpy as npnp.random.seed(0)dt = 0.01Fs = 1/dtt = np.arange(0, 10, dt)nse = np.random.randn(len(t))r = np.exp(-t/0.05)cnse = np.convolve(nse, r)*dtcnse = cnse[:len(t)]s = 0.1*np.sin(2*np.pi*t) + cnseplt.subplot(3, 2, 1)plt.plot(t, s)plt.subplot(3, 2, 2)plt.psd(s, Fs=Fs)plt.subplot(3, 2, 3)plt.magnitude_spectrum(s, Fs=Fs)plt.subplot(3, 2, 4)plt.magnitude_spectrum(s, Fs=Fs, scale='dB')plt.subplot(3, 2, 5)plt.angle_spectrum(s, Fs=Fs)plt.subplot(3, 2, 6)plt.phase_spectrum(s, Fs=Fs) pyplot.psd() 绘制能量谱密度图；pyplot.magnitude_spectrum() 绘制幅度频谱图；pyplot.phase_spectrum() 绘制相角频谱图；pyplot.angle_spectrum() 绘制相位频谱图。 Fs表示采样频率。","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Data Analysis","slug":"Data-Analysis","permalink":"https://lxmymjr.github.io/tags/Data-Analysis/"}]},{"title":"Python Web 框架 - CherryPy","slug":"Python-Web框架-CherryPy","date":"2017-09-19T11:25:14.000Z","updated":"2021-09-16T02:56:10.895Z","comments":true,"path":"contents/Python-Web框架-CherryPy.html","link":"","permalink":"https://lxmymjr.github.io/contents/Python-Web%E6%A1%86%E6%9E%B6-CherryPy.html","excerpt":"CherryPy is a pythonic, object-oriented web framework. CherryPy allows developers to build web applications in much the same way they would build any other object-oriented Python program. This results in smaller source code developed in less time. Reference：官网；GitHub","text":"CherryPy is a pythonic, object-oriented web framework. CherryPy allows developers to build web applications in much the same way they would build any other object-oriented Python program. This results in smaller source code developed in less time. Reference：官网；GitHub 安装 直接执行 $ pip install cherrypy。 也可以从 GitHub 的 CherryPy 获取最新版的源代码并安装： 123$ git clone https://github.com/cherrypy/cherrypy$ cd cherrypy$ python setup.py install 用测试用例检验是否安装成功，直接执行 $ python -m cherrypy.tutorial.tut01_helloworld。 打开页面http://127.0.0.1:8080 或者http://localhost:8080 查看结果。 一旦成功，控制台也会显示log： 12345678ENGINE Listening for SIGHUP.ENGINE Listening for SIGTERM.ENGINE Listening for SIGUSR1.ENGINE Bus STARTINGENGINE Started monitor thread 'Autoreloader'.ENGINE Started monitor thread '_TimeoutMonitor'.ENGINE Serving on http://127.0.0.1:8080ENGINE Bus STARTED Hello World 页面部署 123456789import cherrypyclass HelloWorld(object): @cherrypy.expose def index(self): return \"Hello world!\"if __name__ == '__main__': cherrypy.quickstart(HelloWorld()) 运行此程序后，控制台则会显示： 1234567891011ENGINE Listening for SIGHUP.ENGINE Listening for SIGTERM.ENGINE Listening for SIGUSR1.ENGINE Bus STARTINGCherryPy Checker:The Application mounted at '' has an empty config.ENGINE Started monitor thread 'Autoreloader'.ENGINE Started monitor thread '_TimeoutMonitor'.ENGINE Serving on http://127.0.0.1:8080ENGINE Bus STARTED 前三行表示服务器会处理signal；第四行表示服务器的状态，此刻在启动阶段；第五、六行表示你的应用没有特别的配置；第八、九行表示服务器开始了一些内部的功能，倒数第二行表示已经准备好通信并且监听地址127.0.0.1:8080，最后一行表示现在你的应用已经开始运行，可以使用。 这里return为index页面的源码： - 可以是一般字符串，比如 \"Hello world!\"，页面直接显示字符串 - 可以是HTML格式的字符串，比如 1234567891011121314\"\"\"&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\" src=\"/xxx/xxx/xxx.js\"&gt;&lt;/script&gt; &lt;title&gt;Write Your WebPage Title Here&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/xxx/xxx/xxx.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"xxx\"&gt; Hello world! &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;\"\"\" 这里使用三对双引号，用来输入多行文本，之中的单号和双引号不用转义，其中的不可见字符比如。 - 可以是HTML文件 open('xxx/xxx/xxx.html') 注打开文件的时候可以传递参数 open(\"xxx.html\").read().format(a=a, b=b, c=c, ...)，则HTML文件中 {a:}; {b:}; {c:}; ...来表示相应的字符串。 或者 open(\"xxx.html\").read() % (a, b, c, ...)，HTML文件中 %s;%d;%f 等来表示相应位置的字符串。 原理：open(\"xxx.html\").read() 返回一个string对象，传递参数同格式化输出。 用 cherrypy.quickstart() 启动单个应用，此函数至少需要一个参数，第一个必选一般为类名；第二个可选参数为应用访问的基础路径；第三个可选参数为应用配置。 如果要启动多个应用，则用 cherrypy.tree.mount()，此函数的参数和 cherrypy.quickstart() 一样，均为一个应用的类名，一个主机路径，一个配置。举例如下 12345cherrypy.tree.mount(A(), '/a', a_conf)cherrypy.tree.mount(B(), '/b', b_conf)cherrypy.engine.start()cherrypy.engine.block() 不同的 URLs 对应不同的 functions 123456789101112131415import randomimport stringimport cherrypyclass StringGenerator(object): @cherrypy.expose def index(self): return \"Hello world!\" @cherrypy.expose def generate(self): return ''.join(random.sample(string.hexdigits, 8))if __name__ == '__main__': cherrypy.quickstart(StringGenerator()) 运行此程序后，打开 http://localhost:8080 或者 http://localhost:8080/index 则会显示 Helloworld 界面（index 可以省略）。 而打开 http://localhost:8080/generate 则会运行 generate 函数并返回且显示一个 8 位随机字符串。 此外，开发者可以实现一个 default 方法，如果服务器找不到任何对应的方法时，将会调用 default 方法。 123456789101112131415import randomimport stringimport cherrypyclass StringGenerator(object): @cherrypy.expose def index(self): return \"Hello world!\" @cherrypy.expose def default(self, url): return ''.join(random.sample(string.hexdigits, 8))if __name__ == '__main__': cherrypy.quickstart(StringGenerator()) 运行此程序后，打开http://localhost:8080/xxx 则会运行default函数并返回且显示一个8位随机字符串，这里xxx为任意网址。 注意，default函数必须有两个参数，url会传入用户所访问的网址，即 url=xxx 通过 URL 传递参数 123456789101112131415import randomimport stringimport cherrypyclass StringGenerator(object): @cherrypy.expose def index(self): return \"Hello world!\" @cherrypy.expose def generate(self, length=8): return ''.join(random.sample(string.hexdigits, int(length)))if __name__ == '__main__': cherrypy.quickstart(StringGenerator()) 运行此程序后，打开 http://localhost:8080/generate?length=16 ， 则地址栏中的 16 会被从客户端传递到服务器端，作为 generate 的参数 length 的值，其结果是返回且显示一个长度为 16 的随机字符串。 如果直接访问 http://localhost:8080/generate 则参数为缺省值 length=8。 如果并未设置缺省值也没有通过 url 传递参数则会报错。 提交表单 1234567891011121314151617181920212223import randomimport stringimport cherrypyclass StringGenerator(object): @cherrypy.expose def index(self): return \"\"\"&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;form method=\"get\" action=\"generate\"&gt; &lt;input type=\"text\" value=\"8\" name=\"length\" /&gt; &lt;button type=\"submit\"&gt;Give it now!&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;\"\"\" @cherrypy.expose def generate(self, length=8): return ''.join(random.sample(string.hexdigits, int(length)))if __name__ == '__main__': cherrypy.quickstart(StringGenerator()) 运行此程序后，打开 http://localhost:8080/ ，填写表格并提交。 触发 submit 时候，根据 form 中定义的 action 的名字寻找对应的 function，并将表单元素提交的内容作为 name 属性所对应的参数传递。 Session 一个应用经常需要追踪用户的行为，一个常用的做法是使用 session 暂存数据，并且在客户端服务器通信中保持。 12345678910111213141516171819202122232425262728293031323334import randomimport stringimport cherrypyclass StringGenerator(object): @cherrypy.expose def index(self): return \"\"\"&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;form method=\"get\" action=\"generate\"&gt; &lt;input type=\"text\" value=\"8\" name=\"length\" /&gt; &lt;button type=\"submit\"&gt;Give it now!&lt;/button&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;\"\"\" @cherrypy.expose def generate(self, length=8): some_string = ''.join(random.sample(string.hexdigits, int(length))) cherrypy.session['mystring'] = some_string return some_string @cherrypy.expose def display(self): return cherrypy.session['mystring']if __name__ == '__main__': conf = { '/': { 'tools.sessions.on': True } } cherrypy.quickstart(StringGenerator(), '/', conf) 运行此程序后，打开http://localhost:8080/generate 生成一个随机字符串并存入session的'mystring'字段之中。 打开http://localhost:8080/display 展示session中存储的字符串。 CherryPy会存储session的信息在进程的内存中。 注意此时要修改.conf文件。 12[/]tools.sessions.on = True Cookies CherryPy 使用 Python 模块 Cookie，Cookie.SimpleCookie 对象来处理 cookie 要将 cookie 发送至浏览器，使用 cherrypy.response.cookie[key] = value 要提取浏览器的 cookie，使用 cherrypy.request.cookie[key] 要删除 cookie（在客户端），必须将 cookie 的过期时间设置为 0：cherrypy.response.cookie[key]['expires'] = 0 允许文件上传、下载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osimport os.pathimport cherrypyfrom cherrypy.lib import staticlocalDir = os.path.dirname(__file__)absDir = os.path.join(os.getcwd(), localDir)class FileDemo(object): @cherrypy.expose def index(self): return \"\"\" &lt;html&gt;&lt;body&gt; &lt;h2&gt;Upload a file&lt;/h2&gt; &lt;form action=\"upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; filename: &lt;input type=\"file\" name=\"myFile\" /&gt;&lt;br/&gt; &lt;input type=\"submit\" /&gt; &lt;/form&gt; &lt;h2&gt;Download a file&lt;/h2&gt; &lt;a href='download'&gt;This one&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; \"\"\" @cherrypy.expose def upload(self, myFile): out = \"\"\"&lt;html&gt; &lt;body&gt; myFile length: %s&lt;br /&gt; myFile filename: %s&lt;br /&gt; myFile mime-type: %s &lt;/body&gt; &lt;/html&gt;\"\"\" size = 0 while True: data = myFile.file.read(8192) if not data: break size += len(data) return out % (size, myFile.filename, myFile.content_type) @cherrypy.expose def download(self): path = os.path.join(absDir, 'pdf_file.pdf') return static.serve_file(path, 'application/x-download', 'attachment', os.path.basename(path))if __name__ == '__main__': cherrypy.quickstart(FileDemo()) 上传： 当客户端上传一个文件到 CherryPy 应用时，CherryPy 将会将文件作为一个参数传给方法（upload (self, myFile)）。 此参数有一个 file 属性，可以用于操作临时传入的文件，如果想要永久的保留文件，则需要用 read () 函数读取 myFile.file 的数据并且写入到某个文件中。 下载： 使用响应类型 “application/x-download”，可以告诉浏览器，应该将资源下载到用户的机器上，而不是显示。 serve_file(path, content_type=None, disposition=None, name=None, debug=False) 函数：第一个参数为文件路径；第二个参数为内容类型；第三个参数为 Content-Disposition 信息（Content-Disposition 就是当用户想把请求所得的内容存为一个文件的时候提供一个默认的文件名），如果不为空，则 Content-Disposition header 会被设置为 \"&lt;disposition&gt;; filename=&lt;name&gt;\"，如果 name 为空，则 name 被设置为文件的 basename。 以流形式处理请求主体 CherryPy 收到 HTTP 请求后，对于底层信心进行处理后将请求传给页面处理部分，这里就会生成请求主体 (response body). ChereyPy 支持多种类型的请求主体，如字符串、字符串列表或者文件；同样，也可以通过 yield 内容的方式形成 stream。 默认是关闭流输出的，因为这更加安全也更容易处理；如果要开启这个功能，需要对 session 会话有所了解。 一般请求的处理过程中，HTTP 服务器是一次性将整个请求接受、一次性将整个结果返回。 这对于简单的网页或者静态内容比较合适，因为请求、代码等都可以随时改变。 而流输出中程序不是一次性的返回数据，而是返回生成器，再通过生成器不断的以流的形式获取数据。 使用 response.stream = true 并结合 yield，示例如下： 12345678910111213141516import os.pathimport cherrypyclass HelloWorld(object): @cherrypy.expose def index(self): yield \"Hello \" yield \"world!\"if __name__ == '__main__': conf = { '/': { 'response.stream': True } } cherrypy.quickstart(HelloWorld(), '/', conf) 调用网站资源 网络应用经常会调用一些静态资源，比如 JavaScript，CSS 或 image 等资源。 在网站的根目录下新建文件夹 public，在 public 中可以自己新建文件夹 js，css，image 等子文件夹，并在相应文件夹中存放相应的资源。 在 HTML 调用资源的地方写入： &lt;script type=\"text/javascript\" src=\"/static/js/xxx.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"/static/css/xxx.css\" /&gt; &lt;img src=\"/static/image/xxx.jpg\" alt=\"xxx\" style=\"width:123px;height:123px;\"&gt; 并且修改.conf 文件。 123456[/]tools.staticdir.root = os.path.abspath(os.getcwd())[/static]tools.staticdir.on = Truetools.staticdir.dir = \"public\" 对于独立文件资源： 123[/style.css]tools.staticfile.on = Truetools.staticfile.filename = filepath REST 客户端除了浏览器之外，还有其他一些形式比如 python，iOS，Android 等。 RESTful 可以通过一套统一的接口为他们提供服务。 而且对于很多平台来说，不需要有显式的前端，只需要一套提供服务的接口。 REST 用 URL 定位资源，用 HTTP 动词（GET，POST，PUT，DELETE 等）描述操作。 1234567891011121314151617181920212223242526272829303132import randomimport stringimport cherrypy@cherrypy.exposeclass StringGeneratorWebService(object): @cherrypy.tools.accept(media='text/plain') def GET(self): return cherrypy.session['mystring'] def POST(self, length=8): some_string = ''.join(random.sample(string.hexdigits, int(length))) cherrypy.session['mystring'] = some_string return some_string def PUT(self, another_string): cherrypy.session['mystring'] = another_string def DELETE(self): cherrypy.session.pop('mystring', None)if __name__ == '__main__': conf = { '/': { 'request.dispatch': cherrypy.dispatch.MethodDispatcher(), 'tools.sessions.on': True, 'tools.response_headers.on': True, 'tools.response_headers.headers': [('Content-Type', 'text/plain')], } } cherrypy.quickstart(StringGeneratorWebService(), '/', conf) 运行此程序后，可以使用python的requests库来进行交互。 这里通过@cherrypy.expose装饰器一次性暴露StringGeneratorWebService类的所有方法。 该应用不再是以&lt;URL，函数&gt;匹配的方式进行工作，而是在配置里面创建了cherrypy.dispatch.MethodDispatcher实例，用于自动匹配。 对于get函数强制response的contenttype为text/plain。 1234567891011121314151617181920212223&gt;&gt;&gt; import requests&gt;&gt;&gt; s = requests.Session()&gt;&gt;&gt; r = s.get('http://127.0.0.1:8080/')&gt;&gt;&gt; r.status_code500 # 因为session['mystring']为空，所以产生服务器错误&gt;&gt;&gt; r = s.post('http://127.0.0.1:8080/')&gt;&gt;&gt; r.status_code, r.text(200, u'04A92138') # post提交一个长度为8的随机字符串并存入session中&gt;&gt;&gt; r = s.get('http://127.0.0.1:8080/')&gt;&gt;&gt; r.status_code, r.text(200, u'04A92138') # get获取session中所存的字符串&gt;&gt;&gt; r = s.get('http://127.0.0.1:8080/', headers={'Accept': 'application/json'})&gt;&gt;&gt; r.status_code406 # 因为提出请求，将获取所生成的字符串作为一个JSON格式返回，格式不符所以返回406错误# 406 Not Acceptable 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。&gt;&gt;&gt; r = s.put('http://127.0.0.1:8080/', params={'another_string': 'hello'})&gt;&gt;&gt; r = s.get('http://127.0.0.1:8080/')&gt;&gt;&gt; r.status_code, r.text(200, u'hello') # put更新session中所存的字符串&gt;&gt;&gt; r = s.delete('http://127.0.0.1:8080/')&gt;&gt;&gt; r = s.get('http://127.0.0.1:8080/')&gt;&gt;&gt; r.status_code500 # delete删除session中的字符串，所以产生服务器错误 AJAX AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 是在不重新加载整个页面的情况下与服务器交换数据并更新部分网页的技术。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import os, os.pathimport randomimport stringimport cherrypyclass StringGenerator(object): @cherrypy.expose def index(self): return '''&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; #the-string { display: none; } &lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-2.0.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() { $(\"#generate-string\").click(function(e) { $.ajax({ type: \"POST\", url: \"/generator\", data: {\"length\": $(\"input[name='length']\").val()} }) e.preventDefault(); }); $(\"#replace-string\").click(function(e) { $.ajax({ type: \"PUT\", url: \"/generator\", data: {\"another_string\": $(\"#the-string input\").val()} }) .done(function() { alert(\"Replaced!\"); }); e.preventDefault(); }); $(\"#delete-string\").click(function(e) { $.ajax({ type: \"DELETE\", url: \"/generator\" }) .done(function() { $(\"#the-string\").hide(); }); e.preventDefault(); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" value=\"8\" name=\"length\"/&gt; &lt;button id=\"generate-string\"&gt;Give it now!&lt;/button&gt; &lt;div id=\"the-string\"&gt; &lt;input type=\"text\" /&gt; &lt;button id=\"replace-string\"&gt;Replace&lt;/button&gt; &lt;button id=\"delete-string\"&gt;Delete it&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; '''@cherrypy.exposeclass StringGeneratorWebService(object): @cherrypy.tools.accept(media='text/plain') def GET(self): return cherrypy.session['mystring'] def POST(self, length=8): some_string = ''.join(random.sample(string.hexdigits, int(length))) cherrypy.session['mystring'] = some_string return some_string def PUT(self, another_string): cherrypy.session['mystring'] = another_string def DELETE(self): cherrypy.session.pop('mystring', None)if __name__ == '__main__': conf = { '/': { 'tools.sessions.on': True, 'tools.staticdir.root': os.path.abspath(os.getcwd()) }, '/generator': { 'request.dispatch': cherrypy.dispatch.MethodDispatcher(), 'tools.response_headers.on': True, 'tools.response_headers.headers': [('Content-Type', 'text/plain')], }, } webapp = StringGenerator() webapp.generator = StringGeneratorWebService() cherrypy.quickstart(webapp, '/', conf) 运行此程序后，可以使用按钮触发ajax结合jQuery来进行交互。 其中： 123456789101112$(\"#generate-string\").click(function(e) { $.ajax({ type: \"POST\", url: \"/generator\", data: {\"length\": $(\"input[name='length']\").val()} }) .done(function(string) { $(\"#the-string\").show(); $(\"#the-string input\").val(string); }); e.preventDefault();}); 表示当id为generate-string的按钮被点击后，执行POST命令，目标url是generator，以JSON方式传参数length，length的值为名字等于length的input组件的值。完成POST后服务器返回string，并且将id为the-string的组件显示出来，将其input组件的值赋值为string。 1234567891011$(\"#replace-string\").click(function(e) { $.ajax({ type: \"PUT\", url: \"/generator\", data: {\"another_string\": $(\"#the-string input\").val()} }) .done(function() { alert(\"Replaced!\"); }); e.preventDefault();}); 表示当id为replace-string的按钮被点击后，执行PUT命令，目标url是generator，以JSON方式传参数another_string，another_string的值为id为the-string的组件中的input组件的值。完成PUT后弹出警告框\"Replaced\"。 12345678910$(\"#delete-string\").click(function(e) { $.ajax({ type: \"DELETE\", url: \"/generator\" }) .done(function() { $(\"#the-string\").hide(); }); e.preventDefault();}); 表示当id为delete-string的按钮被点击后，执行DELETE命令，目标url是generator，完成DELETE后将id为the-string的组件隐藏。 数据库存储 这里以 SQLite 数据库为例，演示如何将网页数据存入数据库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137import os, os.pathimport randomimport sqlite3import stringimport timeimport cherrypyDB_STRING = \"my.db\"class StringGenerator(object): @cherrypy.expose def index(self): return '''&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; #the-string { display: none; } &lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-2.0.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; $(document).ready(function() { $(\"#generate-string\").click(function(e) { $.ajax({ type: \"POST\", url: \"/generator\", data: {\"length\": $(\"input[name='length']\").val()} }) e.preventDefault(); }); $(\"#replace-string\").click(function(e) { $.ajax({ type: \"PUT\", url: \"/generator\", data: {\"another_string\": $(\"#the-string input\").val()} }) .done(function() { alert(\"Replaced!\"); }); e.preventDefault(); }); $(\"#delete-string\").click(function(e) { $.ajax({ type: \"DELETE\", url: \"/generator\" }) .done(function() { $(\"#the-string\").hide(); }); e.preventDefault(); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"text\" value=\"8\" name=\"length\"/&gt; &lt;button id=\"generate-string\"&gt;Give it now!&lt;/button&gt; &lt;div id=\"the-string\"&gt; &lt;input type=\"text\" /&gt; &lt;button id=\"replace-string\"&gt;Replace&lt;/button&gt; &lt;button id=\"delete-string\"&gt;Delete it&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; '''@cherrypy.exposeclass StringGeneratorWebService(object): @cherrypy.tools.accept(media='text/plain') def GET(self): with sqlite3.connect(DB_STRING) as c: cherrypy.session['ts'] = time.time() r = c.execute(\"SELECT value FROM user_string WHERE session_id=?\", [cherrypy.session.id]) return r.fetchone() def POST(self, length=8): some_string = ''.join(random.sample(string.hexdigits, int(length))) with sqlite3.connect(DB_STRING) as c: cherrypy.session['ts'] = time.time() c.execute(\"INSERT INTO user_string VALUES (?, ?)\", [cherrypy.session.id, some_string]) return some_string def PUT(self, another_string): with sqlite3.connect(DB_STRING) as c: cherrypy.session['ts'] = time.time() c.execute(\"UPDATE user_string SET value=? WHERE session_id=?\", [another_string, cherrypy.session.id]) def DELETE(self): cherrypy.session.pop('ts', None) with sqlite3.connect(DB_STRING) as c: c.execute(\"DELETE FROM user_string WHERE session_id=?\", [cherrypy.session.id])def setup_database(): \"\"\" Create the `user_string` table in the database on server startup \"\"\" with sqlite3.connect(DB_STRING) as con: con.execute(\"CREATE TABLE user_string (session_id, value)\")def cleanup_database(): \"\"\" Destroy the `user_string` table from the database on server shutdown. \"\"\" with sqlite3.connect(DB_STRING) as con: con.execute(\"DROP TABLE user_string\")if __name__ == '__main__': conf = { '/': { 'tools.sessions.on': True, 'tools.staticdir.root': os.path.abspath(os.getcwd()) }, '/generator': { 'request.dispatch': cherrypy.dispatch.MethodDispatcher(), 'tools.response_headers.on': True, 'tools.response_headers.headers': [('Content-Type', 'text/plain')], }, } cherrypy.engine.subscribe('start', setup_database) cherrypy.engine.subscribe('stop', cleanup_database) webapp = StringGenerator() webapp.generator = StringGeneratorWebService() cherrypy.quickstart(webapp, '/', conf) 运行此程序后，可以使用按钮触发ajax来进行交互。 大部分功能与上一个例子相同，这里增加了将session中的数据存入数据库的功能。 其中 cherrypy.engine.subscribe('start', setup_database) 和 cherrypy.engine.subscribe('stop', cleanup_database) 表示setup_database函数和cleanup_database函数被注册到服务器，当服务器启动和停止时调用。 setup_database函数新建一个名为user_string的表格，cleanup_database函数删除user_string表格。 日志记录 CherryPy 会记录所有的 requests 和协议错误。 应用也可以自己配置日志记录功能，调用 cherrypy.log()。 如果在配置中配置以下内容，则所有的 log 会被记录到文件： - log.access_file 记录 requests 情况 - log.error_file 记录其他的情况 修改.conf 文件。 1234[/]log.screen = False, #用于取消console的logginglog.access_file = \"access.log\",log.error_file = \"error.log\", 服务器配置 全局配置 (global) HTTP 配置 1234[global]server.socket_host = \"127.0.0.1\"server.socket_port = 8080server.thread_pool = 10 HTTPS配置 1234567[global]server.socket_host = \"0.0.0.0\"server.socket_port = 443server.thread_pool = 10server.ssl_module = 'builtin'server.ssl_certificate = \"cert.pem\"server.ssl_private_key = \"privkey.pem\" 可以用OpenSSL工具生成自签名的证书，方法如下： $ openssl genrsa -out privkey.pem 2048 #用于生成私钥 修改 OpenSSL.cnf 配置文件（最好不修改此目录下的文件，而是拷贝一份至你的生成证书的目录） 找到 [v3_ca] 在其下方加入并保存： 123subjectAltName = \"IP:server的ip\"basicConstraints = CA:FALSEkeyUsage = digitalSignature, keyEncipherment $ openssl req -new -x509 -days 365 -key privkey.pem -out cert.pem -config openssl.cnf #用于生成证书 有效期为 365 天，按照提示写入个人信息（国、省、市、机构、组织、server 的 ip、邮箱）。 cert.pem 的后缀改为 cer 就可以作为证书使用了。 网站 Gzip Gzip 开启以后会将输出到用户浏览器的数据进行压缩的处理，这样就会减小通过网络传输的数据量，提高浏览的速度。 修改.conf 文件开启压缩功能。 12[/]tools.gzip.on: True 其他配置 也可以将某些字符串存入配置文件，供各种函数访问。 修改.conf 文件。 12[abc]def = \"ghi\" 在函数中通过 jklmn = cherrypy.request.app.config['abc']['def'] 调用，此时jklmn变量被赋值\"ghi\"，str类型。 处理 JSON CherryPy 内置支持了对 JSON 编码的请求或响应的解码支持。 解码 request 自动解码 JSON 请求的内容： 1234@cherrypy.expose@cherrypy.tools.json_in()def index(self): data = cherrypy.request.json 附加在请求的JSON属性包含解码内容。 编码 response 使用 JSON 自动编码 response 的内容： 1234@cherrypy.expose@cherrypy.tools.json_out()def index(self): return {'key': 'value'} CherryPy将使用JSON对你的页面处理程序返回的任何内容进行编码，并非所有类型的对象都可以被编码。 认证 CherryPy 提供了两种非常简单的身份验证机制。他们最常见的触发方式是触发浏览器弹出窗口向用户询问他们的名字和密码。 Basic Basic 身份验证是最简单的验证方式，但它不是一个安全的身份验证，因为用户的凭证被嵌入到请求中。不建议使用它，除非你在 SSL 或封闭的网络中运行。 123456789101112131415161718from cherrypy.lib import auth_basicUSERS = {'id': 'password'}def validate_password(realm, username, password): if username in USERS and USERS[username] == password: return True return Falseconf = { '/protected/area': { 'tools.auth_basic.on': True, 'tools.auth_basic.realm': 'localhost', 'tools.auth_basic.checkpassword': validate_password }}cherrypy.quickstart(myapp, '/', conf) 必须提供一个将有CherryPy调用的函数，解码从请求中传递的用户名和密码。 该功能可以从任何来源读取数据：文件，数据库，内存等。 Digest Digest 认证的不同之处在于，凭证没有携带在请求中，因此比 Basic 更安全。 1234567891011121314from cherrypy.lib import auth_digestUSERS = {'id': 'password'}conf = { '/protected/area': { 'tools.auth_digest.on': True, 'tools.auth_digest.realm': 'localhost', 'tools.auth_digest.get_ha1': auth_digest.get_ha1_dict_plain(USERS), 'tools.auth_digest.key': 'a565c27146791cfb' }}cherrypy.quickstart(myapp, '/', conf) 网站图标 CherryPy 提供自己的红色 cherrypy 作为默认图标。可以用以下方式提供自己的图标： 1234567891011121314151617import cherrypyclass HelloWorld(object): @cherrypy.expose def index(self): return \"Hello World!\"if __name__ == '__main__': cherrypy.quickstart(HelloWorld(), '/', { '/favicon.ico': { 'tools.staticfile.on': True, 'tools.staticfile.filename': '/path/to/myfavicon.ico' } } ) 也可以使用文件进行配置： 123[/favicon.ico]tools.staticfile.on: Truetools.staticfile.filename: \"/path/to/myfavicon.ico\" 123456789import cherrypyclass HelloWorld(object): @cherrypy.expose def index(self): return \"Hello World!\"if __name__ == '__main__': cherrypy.quickstart(HelloWorld(), '/', app.conf) 设置页面别名 1234567891011import randomimport stringimport cherrypyclass StringGenerator(object): @cherrypy.expose(['generer', 'generar']) def generate(self, length=8): return ''.join(random.sample(string.hexdigits, int(length)))if __name__ == '__main__': cherrypy.quickstart(StringGenerator()) 其中 @cherrypy.expose(['generer', 'generar']) 设置了别名，所以下面三个页面效果是一样：/generate；/generer (French)；/generar (Spanish) 请求超时 CherryPy 包含 3 个时间相关的属性： - response.time：当请求开始的时候，记录 time.time () - response.timeout：请求可以运行的时间，默认 300s - response.timed_out：是否激活超时机制 (默认 False) 可以通过 response.check_timeout 来检查是否超时，在激活超时机制的情况下，一旦超时则触发 TimeoutError 异常。 默认会通过 cherrypy.engine.timeout_monitor 监控所有请求是否超时，如果要关闭： 12[global]engine.timeout_monitor.on: False 或者 1cherrypy.engine.timeout_monitor.unsubscribe() 默认超时监控是1分钟1次，改成1小时1次： 12[global]engine.timeout_monitor.frequency: 60 * 60 信号处理 对于信号处理，有一个 cherrypy.engine.signal_handler 插件，它是被 cherrypy.quickstart () 自动调用的。 如果要手动进行信号处理，则可以调用 tree.mount() 或 engine.start() 或 engine.block()。 记得启动引擎前调用 engine.signals.subscribe()。","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Web Framework","slug":"Web-Framework","permalink":"https://lxmymjr.github.io/tags/Web-Framework/"}]},{"title":"豆瓣爬虫实例","slug":"豆瓣爬虫实例","date":"2017-09-18T13:21:07.000Z","updated":"2021-09-16T02:56:10.897Z","comments":true,"path":"contents/豆瓣爬虫实例.html","link":"","permalink":"https://lxmymjr.github.io/contents/%E8%B1%86%E7%93%A3%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B.html","excerpt":"本文提供 3 个例子来说明如何利用 Python 爬取豆瓣的数据。","text":"本文提供 3 个例子来说明如何利用 Python 爬取豆瓣的数据。 用 requests 获取页面 三个实例都要用到 request 库来获取页面资源。 1234567891011def getHTMLText(url): # 获取网页的HTML源码 try: # 设置响应等待时间为30秒 r = requests.get(url, timeout=30) # 检查状态码是否为200，否则抛出异常。 r.raise_for_status() # 返回请求的相应内容。 return r.text except: # 抛出异常则重试 return getHTMLText(url) 实例一：豆瓣国产电视剧爬虫 观察所需爬取的页面 所需爬取的页面为按时间排序的国产电视剧评分等信息。 查看其源代码发现电视剧列表内容是由 js 加载的。 获取电视剧豆瓣地址列表 打开控制台，观察一下 network 中往返的数据。 观察到网页通过查询 https://movie.douban.com/j/search_subjects?type=tv&amp;tag=国产剧&amp;sort=time&amp;page_limit=20&amp;page_start=0 其中 type 是分类（movie，tv）；tag 是小分类（热门，美剧，英剧，韩剧，日剧，国产剧，港剧，日本动画，综艺）；sort 是排序（recommend，time，rank）；page_limit 是每页展示的电视剧数量（不可修改）；page_start 是起始页面，为 20 的倍数（例如，第一页是 0，第二页是 20 等等）。 返回的是 json 数据，直接读取其 url 字段即可。 12345678910111213141516171819def getTVdramalist(url, Numofpage): # 电视剧豆瓣地址列表 TVdramalist = [] # Numofpage为爬取页面数 for i in range(int(Numofpage)): # 获取第i页网页的资源，20为每页的电视剧记录数 text = getHTMLText(url+str(i*20)) # 由于此url返回json对象，所以将获取到的资源转换为json格式 json_text = json.loads(text) # 获取json中的url字段，存入TVdramalist列表 for j in range(20): dic = json_text['subjects'][j] TVdramalist.append(dic['url']) return TVdramalistmoivelist_url = 'https://movie.douban.com/j/search_subjects?type=tv&amp;tag=国产剧&amp;sort=time&amp;page_limit=20&amp;page_start='Numofpage = 5# 获取最新5*20条电视剧的详情页链接moivelist = getTVdramalist(moivelist_url, Numofpage) 分析电视剧详情页 对于上面获取的每一个 url 对应一个电视剧详情页。 查看其源代码发现电视剧详情内容是由 HTML 加载的。 则用 beautifulsoup 库结合正则表达式 re 库分析并获取所需字段。 12345678910def getTVdramainfo(url, writer): text = getHTMLText(url) # 将获取到的资源转换为soup对象 soup = BeautifulSoup(text) # 找到所需字段 name = soup.find(property=\"v:itemreviewed\").string rating = float(soup.find(property=\"v:average\").string) votes = int(soup.find(property=\"v:votes\").string) episode = int(re.search(u'集数:&lt;/span&gt; (\\d+)&lt;br/&gt;', text).group(1)) duration = int(re.search(u'单集片长:&lt;/span&gt; (\\d+)分钟&lt;br/&gt;', text).group(1)) 从property为v:itemreviewed的标签可以得到电视剧名。 从property为v:average的标签可以得到评分。 从property为v:votes的标签可以得到评分人数。 &lt;span class=\"pl\"&gt;集数:&lt;/span&gt; 12&lt;br/&gt; 和 &lt;span class=\"pl\"&gt;单集片长:&lt;/span&gt; 55分钟&lt;br/&gt; 的标签属性和其他标签的属性都一样，这里直接用正则表达式进行查找反而更方便。 存储所爬信息到数据库 这里使用 sqlite3 库实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def dbtablecreate(): # 执行一条SQL语句，创建ChineseTVdrama表 try: cursor.execute('CREATE TABLE ChineseTVdrama (name TEXT PRIMARY KEY, rating REAL, votes INT, episode INT, duration INT)') print('Table created successfully') except Exception as e: print(e)def dbinsertorupdate(name, rating, votes, episode, duration): # 执行一条SQL语句，插入一条记录 try: cursor.execute('INSERT INTO ChineseTVdrama (name, rating, votes, episode, duration) VALUES (?, ?, ?, ?, ?)', (name, rating, votes, episode, duration)) print('data insert successfully') except: # 如果该数据已经存在，则插入异常，改用更新数据 try: cursor.execute('UPDATE ChineseTVdrama SET rating = ?, votes = ?, episode = ?, duration = ? WHERE name = ?', (rating, votes, episode, duration, name)) print('data update successfully') except Exception as e: print('update: ' + str(e))def dbquery(name): # 以电视剧名称为关键词查询数据库 try: cursor.execute('SELECT name, rating, votes, episode, duration FROM ChineseTVdrama WHERE name = ?', (name)) for row in cursor: return row except Exception as e: print('query: ' + str(e))moivelist_url = 'https://movie.douban.com/j/search_subjects?type=tv&amp;tag=国产剧&amp;sort=time&amp;page_limit=20&amp;page_start='Numofpage = 5# 获取最新5*20条电视剧的详情页链接moivelist = getTVdramalist(moivelist_url, Numofpage)# 连接到SQLite数据库# 如果文件不存在，会自动在当前目录创建doubandatabase = sqlite3.connect('豆瓣.db')# 创建一个Cursorcursor = doubandatabase.cursor()# 创建一个数据库表dbtablecreate()# 从每个电视剧的详情页中获取所需字段存入数据库for i in moivelist: try: getTVdramainfo(i, cursor) except Exception as e: print(e) continue# 关闭Cursorcursor.close()# 提交事务doubandatabase.commit()# 关闭Connectiondoubandatabase.close()conn = sqlite3.connect('豆瓣.db')cursor = conn.cursor()cursor.execute(\"SELECT name FROM sqlite_master WHERE type = 'table'\")for i in cursor.fetchall(): tablename = i[0] cursor.execute(\"SELECT * FROM '{}'\".format(tablename)) with open(tablename + '.csv', 'w', newline='', encoding='utf_8_sig') as csv_file: csv_writer = csv.writer(csv_file) csv_writer.writerow([j[0] for j in cursor.description]) csv_writer.writerows(cursor) 可以用SQLiteSpy.exe查看数据库。 实例二：豆瓣正在上映电影爬虫 观察所需爬取的页面 所需爬取的页面为正在上映电影。 查看其源代码。 获取电影信息 1234567891011121314151617def getnowshowing(url, city): text = getHTMLText(url + city) # 将获取到的资源转换为soup对象 soup = BeautifulSoup(text) # 找到所有样式为lists的标签 lists = soup.find(class_=\"lists\") # 遍历其儿子节点 for eachmoive in lists.children: if type(eachmoive) == bs4.element.Tag: # 找到所需字段 name = eachmoive['data-title'] rating = float(eachmoive['data-score']) votes = int(eachmoive['data-votecount']) if eachmoive['data-duration'].encode('utf-8') == '': duration = 0 else: duration = int(str(eachmoive['data-duration'].encode('utf-8')).split('\\\\')[0].split('\\'')[1]) 从源码发现电影列表内容分为正在上映和即将上映两块，soup.find(class_=\"lists\") 只返回第一个符合条件的标签。 其每一个孩子节点包含每一个电影信息。所有信息都存在孩子节点的 &lt;li&gt; 标签内，所以只取 Tag 对象，Tag 对象的属性访问与字典一样。 注意 data-duration 的值有可能为空，所以要单独判断。 eachmoive ['data-duration'] 返回 'xxx 分钟 ' 的 Unicode 对象，.encode('utf-8') 将 Unicode 对象转换成 string 对象。filter(str.isdigit, str) 提取 str 中数字。 存储所爬信息到数据库 这里使用 sqlite3 库实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354def dbtablecreate(): # 执行一条SQL语句，创建NowShowingMoive表 try: cursor.execute('CREATE TABLE NowShowingMoive (name TEXT PRIMARY KEY, rating REAL, votes INT, duration INT)') print('Table created successfully') except Exception as e: print(e) def dbinsert(name, rating, votes, duration): # 执行一条SQL语句，插入一条记录 try: cursor.execute('INSERT INTO NowShowingMoive (name, rating, votes, duration) VALUES (?, ?, ?, ?)', (name, rating, votes, duration)) print('data insert successfully') except Exception as e: print('insert: ' + str(e))def dbquery(name): # 以电影名称为关键词查询数据库 try: cursor.execute('SELECT name, rating, votes, duration FROM NowShowingMoive WHERE name = ?', (name)) for row in cursor: return row except Exception as e: print('query: ' + str(e))# 连接到SQLite数据库# 如果文件不存在，会自动在当前目录创建doubandatabase = sqlite3.connect('豆瓣.db')# 创建一个Cursorcursor = doubandatabase.cursor()# 如果数据库表已经存在，则删除cursor.execute('DROP TABLE IF EXISTS NowShowingMoive')# 创建一个数据库表dbtablecreate()nowshowing_url = 'https://movie.douban.com/cinema/nowplaying/'city = 'wuhan'nowshowing = getnowshowing(nowshowing_url, city)# 关闭Cursorcursor.close()# 提交事务doubandatabase.commit()# 关闭Connectiondoubandatabase.close()conn = sqlite3.connect('豆瓣.db')cursor = conn.cursor()cursor.execute(\"SELECT name FROM sqlite_master WHERE type = 'table'\")for i in cursor.fetchall(): tablename = i[0] cursor.execute(\"SELECT * FROM '{}'\".format(tablename)) with open(tablename + '.csv', 'w', newline='', encoding='utf_8_sig') as csv_file: csv_writer = csv.writer(csv_file) csv_writer.writerow([j[0] for j in cursor.description]) csv_writer.writerows(cursor) 可以用SQLiteSpy.exe查看数据库。 实例三：豆瓣电影 TOP250 爬虫 观察所需爬取的页面 所需爬取的页面为豆瓣电影 Top250。 查看其源代码。 获取电影信息 12345678910111213141516171819202122def getTop250moive(url, Numofpage): # Numofpage为爬取页面数 for i in range(Numofpage): # 获取第i页网页的资源，25为每页的电影记录数 text = getHTMLText(url+str(i*25)) # 将获取到的资源转换为soup对象 soup = BeautifulSoup(text) # 找到所有样式为info的标签 lists = soup.find_all(class_=\"info\") # 找到所需字段 for eachmoive in lists: name = eachmoive.find(class_=\"title\").string year = int(eachmoive.find('p').get_text().split('\\n')[2].strip()[0:4]) country = eachmoive.find('p').get_text().split('\\n')[2].split('/')[1].strip() rating = float(eachmoive.find(property=\"v:average\").string) # 两种方法都可以 votes = int(str(eachmoive.find(property=\"v:best\").next_sibling.next_sibling.string.encode('utf-8')).split('\\\\')[0].split('\\'')[1]) votes = int(str(eachmoive.find(text=re.compile(u\"人评价\")).encode('utf-8')).split('\\\\')[0].split('\\'')[1]) if eachmoive.find(class_=\"inq\") == None: comment = '' else: comment = eachmoive.find(class_=\"inq\").string 从网址发现，Top250 的电影分别展示在 10 个页面，每个页面展示 25 条电影信息，所以 url 的 start 参数为 25 的倍数，值为 0-9。 从源码发现 soup.find(class_=\"info\") 返回每一个电影的信息所在的标签如图。 从样式为 title 的标签可以得到电影名。 从第一个 p 标签可以返回导演、主演、上映年份、国家、类型等信息，并且是分列 2 行， 用.split('\\n')[2] 得到第 2 行的字符串，.strip()[0:4]) 去掉空格并取前 4 个字符作为年份。 .split('/')[1].strip() 以斜线分隔符分割字符串并取出第二段字符串并去掉前后空格，即国家信息。 从 property 为 v:average 的标签可以得到评分。 由于评分人数从 &lt;span&gt;878960人评价&lt;/span&gt; 标签中获取，但是 span 标签没有任何属性。 所以有两种方法： 1. 通过 find(property=\"v:best\") 找到上一个平行节点，然后通过.next_sibling.next_sibling.string 访问。 2. 通过 eachmoive.find(text=re.compile(u\"人评价\")) 直接用正则表达式查找相应的字符串。 最后通过 filter(str.isdigit, str) 提取 str 中数字。 从样式为 inq 的标签可以得到电影评论，注意电影可能没有评论，所以要单独判断。 存储所爬信息到数据库 这里使用 sqlite3 库实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def dbtablecreate(): # 执行一条SQL语句，创建Top250movie表 try: cursor.execute('CREATE TABLE Top250movie (name TEXT PRIMARY KEY, year INT, country TEXT, rating REAL, votes INT, comment TEXT)') print('Table created successfully') except Exception as e: print(e)def dbinsert(name, year, country, rating, votes, comment): # 执行一条SQL语句，插入一条记录 try: cursor.execute('INSERT INTO Top250movie (name, year, country, rating, votes, comment) VALUES (?, ?, ?, ?, ?, ?)', (name, year, country, rating, votes, comment)) print('data insert successfully') except Exception as e: print('insert: ' + str(e))def dbquery(name): # 以电影名称为关键词查询数据库 try: cursor.execute('SELECT name, year, country, rating, votes, comment FROM Top250movie WHERE name = ?', (name)) for row in cursor: return row except Exception as e: print('query: ' + str(e))# 连接到SQLite数据库# 如果文件不存在，会自动在当前目录创建doubandatabase = sqlite3.connect('豆瓣.db')# 创建一个Cursorcursor = doubandatabase.cursor()# 如果数据库表已经存在，则删除cursor.execute('DROP TABLE IF EXISTS Top250movie')# 创建一个数据库表dbtablecreate()moivelist_url = 'https://movie.douban.com/top250?start='Numofpage = 10# 获取最新10*25条电影信息getTop250moive(moivelist_url, Numofpage)# 关闭Cursorcursor.close()# 提交事务doubandatabase.commit()# 关闭Connectiondoubandatabase.close()conn = sqlite3.connect('豆瓣.db')cursor = conn.cursor()cursor.execute(\"SELECT name FROM sqlite_master WHERE type = 'table'\")for i in cursor.fetchall(): tablename = i[0] cursor.execute(\"SELECT * FROM '{}'\".format(tablename)) with open(tablename + '.csv', 'w', newline='', encoding='utf_8_sig') as csv_file: csv_writer = csv.writer(csv_file) csv_writer.writerow([j[0] for j in cursor.description]) csv_writer.writerows(cursor) 可以用SQLiteSpy.exe查看数据库。 其他 实例一源码 实例二源码 实例三源码 SQLiteSpy 数据库查看器下载 豆瓣爬虫结果下载","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Crawler","slug":"Crawler","permalink":"https://lxmymjr.github.io/tags/Crawler/"},{"name":"Examples","slug":"Examples","permalink":"https://lxmymjr.github.io/tags/Examples/"}]},{"title":"Python NumPy 库基础","slug":"Python-NumPy库基础","date":"2017-09-16T14:08:57.000Z","updated":"2021-09-16T02:56:10.895Z","comments":true,"path":"contents/Python-NumPy库基础.html","link":"","permalink":"https://lxmymjr.github.io/contents/Python-NumPy%E5%BA%93%E5%9F%BA%E7%A1%80.html","excerpt":"NumPy 是 Python 语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数函数库。 Reference：【MOOC】Python 数据分析与展示 - 北京理工大学 -【第一周】数据分析之表示 ; 公开课 ;Document;GitHub","text":"NumPy 是 Python 语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数函数库。 Reference：【MOOC】Python 数据分析与展示 - 北京理工大学 -【第一周】数据分析之表示 ; 公开课 ;Document;GitHub 数据的维度 一维数据 一维数据由对等关系的有序或无序数据构成，采用线性方式组织，对应列表、数组和集合等概念。 列表和数组的区别是： 列表中元素的数据类型可以不同。 数组中元素的数据类型相同。 一维数据的 Python 表示：列表（有序）或者集合（无序）。 二维数据 二维数据由多个一维数据构成，是一维数据的组合形式，表格是典型的二维数据，其中，表头是二维数据的一部分。 二维数据的 Python 表示：列表。 多维数据 多维数据由一维或二维数据在新维度上扩展形成。 多维数据的 Python 表示：列表。 高维数据 高维数据仅利用最基本的二元关系展示数据间的复杂结构。 高维数据的 Python 表示：字典类型或者 JSON、XML、YAML 格式。 NumPy 的数组对象：ndarray NumPy 是一个开源的 Python 科学计算基础库，包含： - 一个强大的 N 维数组对象 ndarray - 广播功能函数 - 整合 C/C++/Fortran 代码的工具 - 线性代数、傅里叶变换、随机数生成等功能 NumPy 是 SciPy、 Pandas 等数据处理或科学计算库的基础。 一般使用 import numpy as np 来引用 numpy 库。 ndarray 意为：N 维数组对象。 ndarray 的好处 数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据。 设置专门的数组对象，经过优化，可以提升这类应用的运算速度。 注：科学计算中，一个维度所有数据的类型往往相同。 数组对象采用相同的数据类型，有助于节省运算和存储空间。 ndarray 由两部分构成 实际的数据 描述这些数据的元数据（数据维度、数据类型等） ndarray 数组一般要求所有元素类型相同（同质），数组下标从 0 开始。 ndarray 在程序中的别名是 array，所以用 np.array () 生成一个 ndarray 数组。 np.array() 输出成 [] 格式，元素由空格分割。 轴（axis）保存数据的维度；秩（rank）轴的数量。 ndarray 对象的属性 属性 说明 .ndim 秩，即轴的数量或维度的数量 .shape ndarray 对象的尺度，对于矩阵：n 行 m 列 .size ndarray 对象元素的个数，即 n*m 的值 .dtype ndarray 对象的元素类型 .itemsize ndarray 对象中每个元素的大小，以字节为单位如果元素均为整数，则缺省为 int32，如果元素中有浮点数，则缺省为 float64。 ndarray 数组的元素类型 数据类型 说明 bool 布尔类型，True 或者 False。 intc 与 C 语言的 int 类型一致，一般是 int32 或者 int64 intp 用于索引的整数，与 C 预言中的 ssize_t 一致，int32 或者 int64 int8 字节长度的整数，取值：[-128, 127] int16 16 位长度的整数，取值：[-32768, 32767] int32 32 位长度的整数，取值：[-231, 231-1] int64 64 位长度的整数，取值：[-263, 263-1] uint8 8 位无符号整数，取值：[0, 255] uint16 16 位无符号整数，取值：[0, 65535] uint32 32 位无符号整数，取值：[0, 232-1] uint64 64 位无符号整数，取值：[0, 264-1] float16 16 位半精度浮点数：1 位符号位，5 位指数，10 位尾数 float32 32 位半精度浮点数：1 位符号位，8 位指数，23 位尾数 float64 64 位半精度浮点数：1 位符号位，11 位指数，52 位尾数 complex64 复数类型，实部和虚部都是 32 位浮点数 complex128 复数类型，实部和虚部都是 64 位浮点数 浮点数：（符号）尾数 * 10 指数 复数：实部 (.real)+ 虚部 i（.imag） 与 Python 对比 Python 语法仅支持整数、浮点数和复数 3 种类型。 科学计算涉及数据较多，对存储和性能都有较高要求。 对元素类型精细定义，有助于 NumPy 合理使用存储空间并优化性能。 对元素类型精细定义，有助于程序员对程序规模有合理评估。 非同质的 ndarray 对象 ndarray 数组可以由非同质的对象构成。 非同质的 ndarray 元素类型为 object 类型。 ndarray 数组的创建 ndarray 数组的创建方法 从 Python 中的列表、元组、列表元祖混合等类型创建 ndarray 数组： np.array(list,tuple) 从字节流（raw bytes）中创建 ndarray 数组。 从文件中读取特定格式中创建 ndarray 数组。 使用 NumPy 中函数创建 ndarray 数组： 函数 说明 np.arange(n,m,k) 类似 range() 函数，返回 ndarray 类型，元素从 n 到 m-k，间隔 k np.ones(shape) 根据 shape 生成一个全 1 数组，shape 是元组类型 np.zeros(shape) 根据 shape 生成一个全 0 数组，shape 是元组类型 np.full(shape,val) 根据 shape 生成一个数组，shape 是元组类型，每个元素的值都是 val np.eye(n) 创建一个正方的 n*n 单位矩阵，对角线为 1，其余为 0 np.ones_like(a) 根据数组 a 的形状生成一个全 1 数组 np.zero_like(a) 根据数组 a 的形状生成一个全 0 数组 np.full_like(a,val) 根据数组 a 的形状生成一个全 1 数组 np.linspace(n,m,k) 根据起止数据等间距地填充数据，形成数据，元素从 n 到 m，间隔 (m-n)/(k-1)，元素个数为 k np.linspace(n,m,k,endpoint=False) 根据起止数据等间距地填充数据，形成数据，元素从 n 到 m-(m-n)/k，间隔 (m-n)/k，元素个数为 k np.linspace(a,b,c,...) 将两个或者多个数组合并成一个新的数组，原数组不变 当 np.array() 不指定 dtype 时，NumPy 将根据数据情况关联一个 dtype 类型。 ndarray 数组的变换 对于创建后的 ndarray 数组，可以对其进行维度变换和元素类型变换。 维度变换： 方法 说明 .reshape(shape) 不改变数组元素，返回一个 shape 形状的新数组，原数组不变 .resize(shape) 与.reshape(shape) 功能一致，但修改原数组 .swapaxes(ax1,ax2) 将数组的其中两个维度进行顺序调换 .flatten() 对数组进行降维，返回折叠后的新的一维数组，原数组不变 .astype(new_type) 对数组中的元素进行类型变化，返回一个新数组，原数组不变 .tolist() ndarray 数组向列表转换 ndarray 数组的操作 数组的索引和切片： - 索引：获取数组中特定位置元素的过程。 - 切片：获取数组元素子集的过程。 一维数组的索引和切片：与 Python 的列表类似 a[n]：返回第 n+1 个元素。如果 n 为负数，则返回倒着数第 n 个元素。 a[n:m:k]：起始编号 n，终止编号 m，步长 k，用冒号分割。如果 n 为空，即 n = 0；如果 m 为空，即 m = len(a)。 多维数组的索引和切片： a[n,m,k,...]：每个维度一个索引值，最外 list 中第 n 个元素，倒数第二外 list 中第 m 个元素，以此类推。如果 n 为负数，则返回倒着数第 n 个元素。 a[n1:m1:k1,n2:m2:k2,n3:m3:k3,...]：每个维度的切片方法与一维数组相同。顺序为从外到内。 ndarray 数组的运算 数组与标量之间的运算作用于数组的每一个元素。 NumPy 一元函数 对 ndarray 中的数据执行元素级运算的函数： 函数 说明 np.abs(x) or np.fabs(x) 计算数组各元素的绝对值 np.sqrt(x) 计算数组各元素的平方根 np.sqare(x) 计算数组各元素的平方 np.log(x) or np.log10(x)ornp.log2(x) 计算数组各元素的自然对数、10 为底的对数、2 为底的对数 np.ceil(x) or np.floor(x) 计算数组各元素的向上取整、向下取整 np.rint(x) 计算数组各元素的四舍五入 np.modf(x) 将数组各元素的小数部分和整数部分以两个独立数组形式返回 np.cos(x) or np.cosh(x)np.cos(x) or np.cosh(x)np.cos(x) or np.cosh(x) 计算数组各元素的普通型和双曲型三角函数 np.exp(x) 计算数组各元素的指数值 np.sign(x) 计算数组各元素的符号值：1 (+),0,-1 (-) NumPy 二元函数 函数 说明 + - * / ** 两个数组各元素进行对应运算 np.maximum(x,y) or np.fmax(x,y)ornp.minimum(x,y) or np.fmin(x,y) 两个数组元素级的最大值、最小值计算 np.mod(x,y) 两个数组元素级的模运算 np.copysign(x,y) 将数组 y 中的各元素值的符号赋值给数组 x 的对应元素 &gt; &lt; &gt;= &lt;= == != 算术比较两个数组各元素，产生布尔型数组 Numpy 数据的存取 一维、二维数据的 CSV 存取 CSV (Comma‐Separated Value，逗号分隔值)，CSV 是一种常见的文件格式，用来存储批量数据。 写入 CSV 文件：np.savetxt(fname, array, fmt, delimiter)，其中 fname 指的是文件、字符串或者产生器，可以是.gz 或.bz2 压缩文件（NumPy 支持直接存入压缩文件以节省空间）；array 指的是需要存入的数组；fmt 指的是写入文件的格式，例如：% d (十进制整数) %.2f (保留 2 位小数的浮点数) %.18e (保留 18 位小数点的科学计数法)；delimiter 指的是分割字符串，默认是空格。 读取 CSV 文件：np.loadtxt(fname, dtype, fmt, delimiter)，其中 fname 指的是文件、字符串或者产生器，可以是.gz 或.bz2 压缩文件（NumPy 支持直接读取压缩文件）；dtype 指的是读取数据的类型，默认为浮点类型；delimiter 指的是分割字符串，默认是空格；uppack 指的是如果 True，读入属性将写入不同变量。 CSV 文件的局限性： - CSV 只能有效存储一维和二维数组。 - np.savetxt()；np.loadtxt() 只能有效存取一维和二维数组。 多维数据的 dat 存取 使用 tofile 函数保存多维数据： 写入 dat 文件：a.tofile(fname, sep, format)，其中 a 指的是需要存入的数组；fname 指的是文件、字符串；sep 指的是数据分割字符串，如果是空格，写入文件为二进制。 读取 dat 文件：np.fromfile(fname, dtype, count, sep)，其中 fname 指的是文件、字符串；dtype 指的是读取数据的类型；count 指的是读取数据的个数，如果 count=-1 则表示读入整个文件；sep 指的是数据分割字符串，如果是空格，以二进制读取文件。 注意：该方法需要读取时知道存入文件时数组的维度和元素类型，a.tofile () 和 np.fromfile () 需要配合使用，可以通过元数据文件来存储额外信息。 NumPy 便捷文件的存取 写入文件：np.save(fname, array)，其中 fname 指的是文件名，以.npy 或者.npz 为扩展名，后者为压缩文件；array 指的是需要存入的数组。 读取文件：np.load(fname)，其中 fname 指的是文件名，以.npy 或者.npz 为扩展名，后者为压缩文件。 NumPy 的随机数函数 NumPy 的随机函数子库：np.random.* 包含有关随机数的函数。 随机数组生成 函数 说明 rand(d0, d1, ..., dn) 根据 d0-dn 创建随机数数组，浮点数，[0, 1)，均匀分布 randn(d0, d1, ..., dn) 根据 d0-dn 创建随机数数组，标准正太分布 randint(low[,high,shape]) 根据 shape 创建随机整数数组 范围是 [1ow, high)，均匀分布 seed(s) 随机数种子 s 是给定的种子值，相同的种子值产生相同的随机数组 uniform(low,high,size) 产生具有均匀分布的数组，low 为起始值，high 为结束值，size 为形状 normal(loc,scale,size) 产生具有正太分布的数组，loc 为均值，scale 为标准差，size 为形状 poisson(lam,size) 产生具有泊松分布的数组，lam 为随机事件发生率，size 为形状 数组的随机变换 函数 说明 shuffle(a) 根据数组 a 的第 1 轴进行随机排列，改变数组 x permutation(a) 根据数组 a 的第 1 轴产生一个新的乱序数组，不改变数组 x choice(a[, size, replace, p]) 从一维数组 a 中以概率 p 抽取元素，形成 size 形状新数组replace 表示是否可以重用元素，默认为 True NumPy 的统计函数 函数 说明 sum(a, axis = None) 根据给定轴 axis 计算数组 a 相关元素之和 mean(a, axis = None) 根据给定轴 axis 计算数组 a 相关元素的期望 average(a, axis = None, weights = None) 根据给定轴 axis 计算数组 a 相关元素的加权平均值 std(a, axis = None) 根据给定轴 axis 计算数组 a 相关元素的标准差 var(a, axis = None) 根据给定轴 axis 计算数组 a 相关元素的方差 min(a) max(a) 计算数组 a 中元素的最小值、最大值 argmin(a) argmax(a) 计算数组 a 中元素最小值、最大值的降一维后下标 unravel_index(index, shape) 根据 shape 将一维下标 index 转换成多维下标 ptp(a) 计算数组 a 中元素最大值与最小值的差 median(a) 计算数组 a 中元素的中位数（中值），结果为浮点数 ・axis = None 是统计函数的标配参数，axis 为整数或元组。 NumPy 的梯度函数 np.gradient(f)：计算数组 f 中元素的梯度，当 f 为多维时，返回每个维度的梯度。 梯度：连续值之间的变化率，即斜率。例如：XY 坐标轴连续三个 X 坐标对应的 Y 轴值：a, b, c，其中，b 的梯度是 (c-a)/2。 图像的数据表示 图像一般使用 RGB 色彩模式，即每个像素点的颜色由红 (R)、绿 (G)、蓝 (B) 组成。 RGB 三个颜色通道的变化和叠加得到各种颜色，其中 ・R 红色，取值范围：0‐255 ・G 绿色，取值范围：0‐255 ・B 蓝色，取值范围：0‐255 RGB 形成的颜色包括了人类视力所能感知的所有颜色。 PIL 库 Python Image Library： 安装：pip install pillow 调用：from PIL import Image Image 是 PIL 库中代表一个图像的类（对象）。 图像是一个三维数组，维度分别是高度、宽度和像素 RGB 值。","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Data Analysis","slug":"Data-Analysis","permalink":"https://lxmymjr.github.io/tags/Data-Analysis/"}]},{"title":"Python 爬虫","slug":"Python爬虫","date":"2017-09-10T14:13:01.000Z","updated":"2021-09-16T02:56:10.896Z","comments":true,"path":"contents/Python爬虫.html","link":"","permalink":"https://lxmymjr.github.io/contents/Python%E7%88%AC%E8%99%AB.html","excerpt":"网络爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。 本文介绍基本的网络爬虫的方法，并给出一个具体实例。 Reference：公开课","text":"网络爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。 本文介绍基本的网络爬虫的方法，并给出一个具体实例。 Reference：公开课 爬虫许可 大部分网站都会在其网站根网址上发布 robots 协议 如豆瓣网：https://www.douban.com/robots.txt 12345678910111213141516171819202122User-agent: *Disallow: /subject_searchDisallow: /amazon_searchDisallow: /searchDisallow: /group/searchDisallow: /event/searchDisallow: /celebrities/searchDisallow: /location/drama/searchDisallow: /forum/Disallow: /new_subjectDisallow: /service/iframeDisallow: /j/Disallow: /link2/Disallow: /recommend/Disallow: /trailer/Disallow: /doubanapp/cardSitemap: https://www.douban.com/sitemap_index.xmlSitemap: https://www.douban.com/sitemap_updated_index.xml# Crawl-delay: 5User-agent: Wandoujia SpiderDisallow: / Requests 库 Reference：Python 网络爬虫与信息提取 (一)：网络爬虫之规则 安装：pip install requests。 Requests 库的主要方法 方法 说明 requests.request() 构造一个请求，支撑以下各方法的基础方法 requests.get() 获取 HTML 网页的主要方法，对应于 HTTP 的 GET，请求获取 url 位置的资源 requests.head() 获取 HTML 网页头信息的方法，对应于 HTTP 的 HEAD，请求获取 url 位置资源的响应消息报告，获得该资源的头部信息 requests.post() 向 HTML 网页提交 post 请求的方法，对应于 HTTP 的 POST，请求向 url 位置的资源后附加新的数据 requests.put() 向 HTML 网页提交 put 请求的方法，对应于 HTTP 的 PUT，请求向 url 位置存储一个资源，覆盖原 url 位置的资源 requests.patch() 向 HTML 网页提交局部修改请求的方法，对应于 HTTP 的 PATCH，请求局部更新 url 位置的资源，即改变该处资源的部分内容 requests.delete() 向 HTML 网页提交删除请求的方法，对应于 HTTP 的 DELETE，请求删除 url 位置存储的资源 get 方法 在爬虫中主要使用 get 方法，其他方法参数与 get 方法类似。 r = requests.get(url): 右边构造一个向服务器请求资源的 Requests 对象，左边返回一个包含服务器资源的 Response 对象给 r。 完整参数:requests.get(url,params=None,**kwargs), 实则由 request 方法封装。 Resonse 对象的五个属性： 属性 说明 r.status_code HTTP 请求的返回状态，200 表示连接成功，404 表示失败 r.text HTTP 响应内容的字符串形式，即 url 对应的页面内容 r.encoding HTTP header 中猜测的响应内容编码方式 r.apparent_encoding 从内容中分析出的响应内容编码方式（备选编码方式） r.content HTTP 响应内容的二进制形式 异常处理 异常 说明 requests.ConnectionError 网络连接错误异常，如 DNS 查询失败、拒绝连接等 requests.HTTPError HTTP 错误异常 requests.URLRequired url 缺失异常 requests.TooManyRedirects 超过最大重定向次数，产生重定向异常 requests.ConnectTimeout 连接远程服务器超时异常 requests.Timeout 请求 url 超时，产生超时异常 使用 r.raise_for_status () 方法构建通用代码框架： 12345678def getHTMLText(url) try: r = requests.get(url,timeout = 30) r.raise_for_status() r.encoding = r.apparent_encoding return r.text except: return \"Error\" Requests 库主要方法 requests.request(method,url,**kwargs) - method (请求方式) 包括：GET/HEAD/POST/PUT/PATCH/DELETE/OPTIONS。 - **kwargs (控制访问参数) 包括:params (添加键值到 url 后)/data (字典 / 字节序列等作为 Request 的内容)/json/headers (HTTP 定制头)/cookies (Request 中的 cookie)/auth (元祖，支持 HTTP 认证)/files (传输文件)/timeout/proxies (设定访问代理服务器)/allow_redirects (重定向开关)/stream (获取内容立即下载开关)/verify (认证 SSL 证书开关)/cert (本地 SSL 证书路径)。 Beautiful Soup 库 Beautiful Soup 库可对 HTML/XML 格式进行解析并提取相关信息。 Beautiful Soup 库是解析 / 遍历 / 维护 \"标签\" 的功能库，引用方式：from bs4 import BeautifulSoup。 Reference：Python 网络爬虫与信息提取 (二)：网络爬虫之提取 安装：pip install beautifulsoup4。 Beautiful Soup 库的解析器 解析器 使用方法 条件 HTML 解析器 BeautifulSoup(mk,'html.parser') 安装 bs4 库 lxml 的 HTML 解析器 BeautifulSoup(mk,'lxml') pip install lxml lxml 的 XML 解析器 BeautifulSoup(mk,'xml') pip install lxml html5lib 的解析器 BeautifulSoup(mk,'html5lib') pip install html5lib Beautiful Soup 类的基本元素 基本元素 说明 Tag 标签，最基本的信息组织单元，分别用 &lt;&gt; 和 &lt;/&gt; 标明开头和结尾 Name 标签的名字，&lt;p&gt;...&lt;/p&gt; 的名字是 'p'，格式：&lt;tag&gt;.name Attributes 标签的属性，字典形式组织，格式：&lt;tag&gt;.attrs 或者 &lt;tag&gt;['attrs'] NavigableString 标签内非属性字符串，&lt;&gt;...&lt;/&gt; 中的字符串，格式：&lt;tag&gt;.string Comment 标签内字符串的注释部分，一种特殊的 Comment 类型 任何存在于 HTML 语法中的标签都可用 soup.&lt;tag&gt; 访问获得，存在多个取第一个。 每个 &lt;tag&gt; 有自己的名字，通过 &lt;tag&gt;.name 获取，字符串类型。 每个 &lt;tag&gt; 有 0 或多个属性，字典类型。 每个 &lt;tag&gt; 内有字符串，可以跨越多个标签层次，如果字符串不是注释，则 NavigableString 类型。 如果 &lt;tag&gt; 内的字符串是注释，则返回 Comment 类型。 HTML 内容遍历方法 属性 说明 遍历方式 .contents |子节点的列表，将 &lt;tag&gt; 所有儿子节点存入列表 下行遍历 .children |子节点的迭代类型，与.contents类似，用于循环遍历儿子节点 .descendants |子孙节点的迭代类型，用于循环遍历子孙节点 .parent |节点的父标签 上行遍历 .parents |节点先辈标签的迭代类型，用于循环遍历先辈节点 .next_sibling |返回按照HTML文本顺序的下一个平行节点标签 平行遍历 .previous_sibling | 返回按照 HTML 文本顺序的上一个平行节点标签 .next_siblings | 迭代类型，返回按照 HTML 文本顺序的后续所有平行节点标签 .previous_siblings | 迭代类型，返回按照 HTML 文本顺序的前续所有平行节点标签 12345678910111213for child in soup.body.children: print(child) #遍历儿子节点for descendant in soup.body.descendants: print(descendant) #遍历子孙节点for parent in soup.body.parents: if parent is None: print(parent) else: print(parent.name)for sibling in soup.a.next_siblings: print(sibling)for sibling in soup.a.previous_siblings: print(sibling) HTML 格式输出 使用 prettify() 方法，为 HTML 文本 &lt;&gt; 及其内容增加 '' 并且可用于标签 / 方法。 HTML 内容查找方法 &lt;&gt;.find_all(name,attrs,recursive,text='',**kwargs) 返回一个列表类型，存储查找的结果 name: 对标签名称的检索字符串 attrs: 对标签属性值的检索字符串，可标注属性检索，如果 attrs 是 class，则替换为 class_。 recursive: 是否对子孙全部搜索，默认 True text='': 对字符串域进行检索，其中可以用 re.compile () 来进行正则表达式检索 由.find_all() 扩展的七个方法: 方法 说明 &lt;&gt;.find() 搜索且只返回一个结果，同.find_a11() 参数 &lt;&gt;.find_parents() 在先辈节点中搜索，返回列表类型，同.find_all() 参数 &lt;&gt;.find_parent() 在先辈节点中返回一个结果，同.find() 参数 &lt;&gt;.find_next_siblings() 在后续平行节点中搜索，返回列表类型，同.find_a11() 参数 &lt;&gt;.find_next_sibling() 在后续平行节点中返回一个结果，同.find() 参数 &lt;&gt;.find_previous_siblings() 在前续平行节点中搜索，返回列表类型，同.find_a11() 参数 &lt;&gt;.find_previous_sibling() 在前续平行节点中返回一个结果，同.find() 参数 信息组织与提取方法 信息标记的三种形式及比较： XML (Extensible Markup Language) 是最早的通用信息标记语言，可扩展性好，但繁琐；标签由名字和属性构成，形式有： 123&lt;name&gt;...&lt;/name&gt;&lt;name/&gt;&lt;!-- --&gt; JSON(JavaScript Objection Notation)适合程序处理，较XML简洁;有类型的键值对，形式有： 123\"key\":\"value\"\"key\":[\"value1\",\"value2\"]\"key\":{\"subkey\":\"subvalue\"} YAML(YAML Ain't Markup Language)文本信息比例最高，可读性好;无类型的键值对，形式有： 123456key:valuekey:#Comment-value1-value2key: subkey:subvalue Re (正则表达式) 库 regular expression = regex = RE 是一种通用的字符串表达框架，用来简洁表达一组字符串的表达式，也可用来判断某字符串的特征归属。 Reference：Python 网络爬虫与信息提取 (三)：网络爬虫之实战 ;Python 正则表达式指南 正则表达式的语法 普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 非打印字符 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 字符 描述 \\cx 匹配由 x 指明的控制字符。例如，\\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\d 匹配任何数字。等价于 [0-9]。 \\D 匹配任何非数字。等价于 [^\\d]。 \\w 匹配任何单词字符。等价于 [a-zA-Z0-9_]。 \\W 匹配任何非单词字符。等价于 [^\\w]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^\\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 所谓特殊字符，就是一些有特殊含义的字符。 若要匹配这些特殊字符，必须首先使字符 \"转义\"，即，将反斜杠字符。下表列出了正则表达式中的特殊字符： 特别字符 描述 ^ 匹配输入字符串的开始位置，在多行模式中匹配每一行的结尾。除非在方括号表达式中使用，此时它表示不接受该字符集合。 $ 匹配输入字符串的结尾位置，在多行模式中匹配每一行的结尾。 (...) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。从表达式左边开始每遇到一个分组，则编号 + 1。分组表达式作为一个整体可以后接数量词。表达式中的 | 仅在分组中有效。 (?P&lt;name&gt;...) 分组，除了原有编号外再指定额外别名。 \\&lt;number&gt;(&lt;?P=name) 引用编号为 number 或者别名为 name 的分组。 [...] 字符集，对应的位置可以是字符集中任意字符。 字符集中的字符可以逐个列出，也可以给出范围，如 [abc] 或 [a-c]。第一个字符如果是 ^ 则表示取反，如 [^abc] 表示不是 a 或 b 或 c 的其他字符。所有的特殊字符在字符集中都失去其原有的特殊含义。在字符集中如果要使用] 或 - 或 ^，可以在前面加上反斜杠，或者把] 或 - 放在第一位，把 ^ 放在非第一位。 {n} n 是一个非负整数。匹配确定的 n 次。 {n,} n 是一个非负整数。至少匹配 n 次。{1,} 等价于 +。{0,} 则等价于 *。 {n,m} m 和 n 均为非负整数，其中 n&lt;=m。最少匹配 n 次且最多匹配 m 次。{0,1} 等价于 ?。请注意在逗号和两个数之间不能有空格。 * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次。 . 匹配除换行符 \\n 之外的任何单字符。在 DOTALL 模式中也能匹配换行符。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。 | 左右表达式任意一个。 经典实例 正则表达式 匹配字符串 ^[A-Za-z]+$ 由 26 个字母组成的字符串 ^[A-Za-z0-9]+$ 由 26 个字母和数字组成的字符串 ^-?\\d+$ 整数形式的字符串 ^[1-9][0-9]*$ 正整数形式的字符串 [\\u4e00-\\u9fa5] 匹配中文字符 正则表达式相关注解 数量词的贪婪模式与非贪婪模式 正则表达式通常用于在文本中查找匹配的字符串。Python 里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；非贪婪的则相反，总是尝试匹配尽可能少的字符。实际我们一般使用非贪婪模式来提取。 反斜杠问题 与大多数编程语言相同，正则表达式里使用 \\ 作为转义字符，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符 \\，那么使用编程语言表示的正则表达式里将需要 4 个反斜杠 \\\\\\\\：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。 Python 里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用 r'\\\\' 表示。同样，匹配一个数字的 \\\\d 可以写成 r'\\d'。使用原生字符串，就不用担心漏写了反斜杠，写出来的表达式也更直观。 Re 库的基本使用 正则表达式的表示类型为 raw string 类型 (原生字符串类型), 表示为 r'text'。 Re 库主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回 match 对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回 match 对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是 match 对象 re.sub() 在一个字符串中替换所有匹配正则表达式的子串，返回替换后的字符串 search 方法 re.search(pattern, string, flags = 0) 参数 flag 是匹配模式，取值可以使用按位或运算符’|’表示同时生效。 其他方法的参数与 search 类似。sub 方法多一个参数 repl，re.sub(pattern, repl, string, flags = 0)。 flag 说明 re.I(IGNORECASE) 忽略大小写 re.M(MULTILINE) 多行模式，改变 '^' 和 '$' 的行为 re.S(DOTALL) 点任意匹配模式，改变 '.' 的行为 re.L(LOCALE) 使预定字符类 re.U(UNICODE) 使预定字符类 re.X(VERBOSE) 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。 Match 对象 一次匹配的结果，包含了很多关于此次匹配的信息，可以使用 Match 提供的可读属性或方法来获取这些信息。 属性 属性 说明 string 匹配时使用的文本。 re 匹配时使用的 Pattern 对象。 pos 文本中正则表达式开始搜索的索引。值与 Pattern.match () 和 Pattern.seach () 方法的同名参数相同。 endpos 文本中正则表达式结束搜索的索引。值与 Pattern.match () 和 Pattern.seach () 方法的同名参数相同。 lastindex 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为 None。 lastgroup 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为 None。 方法 方法 说明 group([group1, …]) 获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。可以使用编号也可以使用别名。编号 0 代表整个匹配的子串，不填写参数时，返回 group(0)，没有截获字符串的组返回 None，截获了多次的组返回最后一次截获的子串。 groups([default]) 以元组形式返回全部分组截获的字符串。相当于调用 group(1,2,…last)。default 表示没有截获字符串的组以这个值替代，默认为 None。 groupdict([default]) 返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default 含义同上。 start([group]) 返回指定的组截获的子串在 string 中的起始索引（子串第一个字符的索引）。group 默认值为 0。 end([group]) 返回指定的组截获的子串在 string 中的结束索引（子串最后一个字符的索引 + 1）。group 默认值为 0。 span([group]) 返回 (start(group), end(group))。 expand(template) 将匹配到的分组代入 template 中然后返回。template 中可以使用 \\id 或 \\g&lt;id&gt; 或 \\g&lt;name&gt; 引用分组，但不能使用编号 0。\\id 与 \\g&lt;id&gt; 是等价的，但 \\10 将被认为是第 10 个分组，如果你想表达 \\1 之后是字符'0'，只能使用 \\g&lt;1&gt;0。 Pattern 对象 Pattern 对象是一个编译好的正则表达式，通过 Pattern 提供的一系列方法可以对文本进行匹配查找。 Pattern 不能直接实例化，必须使用 re.compile () 进行构造。 Pattern 提供了几个可读属性用于获取表达式的相关信息： 属性 说明 pattern 编译时用的表达式字符串。 flags 编译时用的匹配模式。数字形式。 groups 表达式中分组的数量。 groupindex 以表达式中有别名的组的别名为键、以该组对应的编号为值的字典，没有别名的组不包含在内。 所以 re.xxx(pattern, string, flags = 0) 可以写做 pattern.xxx(string, flag)。 SQLite 库 SQLite 简介 轻量级 速度快 无需部署 没有服务器 很少或不需要进行管理 由于 SQLite 数据库的驱动已经在 Python 里面了，可以直接使用 import sqlite3 创建数据库 conn = sqlite3.connect(\"数据库名称.db\") 如果数据库不存在，那么它就会被创建，最后将返回一个数据库对象。 创建游标对象 cur = conn.cursor() 创建数据库表 12345try: cursor.execute('CREATE TABLE 表名称 (键1 键类型 PRIMARY KEY, 键2 键类型, 键3 键类型, ...)') print(\"Table created successfully\")except Exception as e: print(e) 这里 ' 键 i' 为键的名称，其中键 1 为主键，键类型有 TEXT（文本字符串，使用数据库编码 UTF-8、UTF-16BE 或 UTF-16LE 存储），REAL（浮点值，存储为 8 字节的 IEEE 浮点数字），INT（带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中），NULL（空值）。 INSERT 操作 单个插入 12345try: cursor.execute('INSERT INTO 表名称 (键1, 键2, 键3, ...) VALUES (值1, 值2, 值3, ...)') print('data insert successfully')except Exception as e: print(e) 批量插入 123456try: data = [(\"值11\", \"值12\", \"值13\", ...), (\"值21\", \"值22\", \"值23\", ...), (\"值31\", \"值32\", \"值33\", ...)] cursor.execute('INSERT INTO 表名称 (?, ?, ?, ...)', data) print('data insert successfully')except Exception as e: print(e) UPDATE 操作 12345try: cursor.execute('UPDATE 表名称 SET 键1 = 值1, 键2 = 值2, 键3 = 值3, ... WHERE 键1 = 值1, 键2 = 值2, 键3 = 值3, ...') print('data update successfully')except Exception as e: print(e) SELECT 操作 123456try: cursor.execute('SELECT 键1, 键2, 键3, ... FROM 表名称 WHERE 键1 = 值1, 键2 = 值2, 键3 = 值3, ...') for row in cursor: print(row)except Exception as e: print(e) DELETE 操作 123456try: c.execute(\"DELETE FROM 表名称 WHERE 键1 = 值1, 键2 = 值2, 键3 = 值3, ...\") for row in cursor: print(row)except Exception as e: print(e) 关闭数据库 123cursor.close() # 关闭Cursorconn.commit() # 提交事务conn.close() # 关闭Connection 将数据库中的数据导出为 csv 文件： 12345678910conn = sqlite3.connect('文件名.db')cursor = conn.cursor()cursor.execute(\"SELECT name FROM sqlite_master WHERE type = 'table'\")for i in cursor.fetchall(): tablename = i[0] cursor.execute(\"SELECT * FROM '{}'\".format(tablename)) with open(tablename + '.csv', 'w', newline='', encoding='utf_8_sig') as csv_file: csv_writer = csv.writer(csv_file) csv_writer.writerow([j[0] for j in cursor.description]) csv_writer.writerows(cursor)","categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Crawler","slug":"Crawler","permalink":"https://lxmymjr.github.io/tags/Crawler/"}]},{"title":"Git Tutorials","slug":"Git-Tutorials","date":"2017-09-01T08:12:42.000Z","updated":"2021-09-16T02:56:10.893Z","comments":true,"path":"contents/Git-Tutorials.html","link":"","permalink":"https://lxmymjr.github.io/contents/Git-Tutorials.html","excerpt":"Git 指南，参考 git - 简明指南","text":"Git 指南，参考 git - 简明指南 安装 MAC 版 Windows 版 Linux 版 指令 创建新仓库：本地创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。 克隆仓库：执行 git clone /path/to/repository 以创建一个本地仓库的克隆版本；如果是远端服务器上的仓库，执行 git clone username@host:/path/to/repository。 工作流：你的本地仓库由 git 维护的三棵 “树” 组成。第一个是你的工作目录，它持有实际文件；第二个是暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。 查看不同：你可以修改你的文档或者代码，并且可以通过 git diff 查看具体修改内容和 git diff --stat 查看修改的总体信息。 添加和提交：你可以提出更改（把它们添加到暂存区），执行 git add &lt;filename&gt; 或 git add *，这是 git 本工作流程的第一步；执行 git commit -m \"代码提交信息\" 以实际提交改动，现在你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动：改动被提交到本地仓库的 HEAD 后，执行 git push origin master 以将这些改动提交到远端仓库（可以把 master 换成你想要推送的任何分支）。如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，执行 git remote add origin &lt;server&gt; 以添加服务器。执行 git remote -v 查看远程服务器。 分支：分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是 “默认的” 分支。在其他分支上进行开发，完成后再将它们合并到主分支上。执行 git checkout -b feature_x 以创建一个叫做 “feature_x” 的分支，并切换过去；执行 git checkout master 以切换回主分支；执行 git checkout master 以删除新建的分支；除非你将分支推送到远端仓库 git push origin &lt;branch&gt;，不然该分支就是不为他人所见的；执行 git branch 查看本地分支。 更新与合并：执行 git pull 以更新你的本地仓库至最新改动（在你的工作目录中获取并合并远端的改动）。执行 git merge &lt;branch&gt; 以合并其他分支到你的当前分支（例如 master）。git 会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突。 这时候就需要你手动修改这些文件来合并这些冲突。改完之后，你需要执行 git add &lt;filename&gt; 以将它们标记为合并成功。在合并改动之前，可以执行 git diff &lt;source_branch&gt; &lt;target_branch&gt; 以预览差异。 标签：推荐为软件发布创建标签，你可以执行 git tag 1.0.0 1b2e1d63ff 以创建一个叫做 1.0.0 的标签，其中 1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以执行 git log 以获取提交 ID，你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。 历史记录：执行 git log 以了解本地仓库的历史记录。 替换本地改动：假如你操作失误，执行 git checkout -- &lt;filename&gt; 替换掉本地改动，此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：执行 git fetch origin 和 git reset --hard origin/master。","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/categories/Tutorial/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"}]},{"title":"Android 实现自签名 HTTPS 教程","slug":"Android实现自签名HTTPS教程","date":"2017-03-10T05:38:04.000Z","updated":"2021-09-16T02:56:10.892Z","comments":true,"path":"contents/Android实现自签名HTTPS教程.html","link":"","permalink":"https://lxmymjr.github.io/contents/Android%E5%AE%9E%E7%8E%B0%E8%87%AA%E7%AD%BE%E5%90%8DHTTPS%E6%95%99%E7%A8%8B.html","excerpt":"本文使用 okhttp 的封装类 okhttp-utils 实现 https 通讯 okhttp-utils 对应 okhttp 版本 3.3.1.","text":"本文使用 okhttp 的封装类 okhttp-utils 实现 https 通讯 okhttp-utils 对应 okhttp 版本 3.3.1. 安装 Android Studio compile 'com.zhy:okhttputils:2.6.2' Eclipse 下载最新 jar:okhttputils-2_6_2.jar。 注：需要同时导入 okhttp 和 okio 的 jar，下载见：https://github.com/square/okhttp。 配置 OkhttpClient 和 SSL 证书 在 onCreate 函数中 1234567891011121314151617InputStream certification = null;try { certification = getAssets().open(\"xxxxx.cer\");} catch (IOException e) { e.printStackTrace();}HttpsUtils.SSLParams sslParams = HttpsUtils.getSslSocketFactory(new InputStream[]{certification}, null, null);OkHttpClient okHttpClient = new OkHttpClient.Builder() .hostnameVerifier(new HostnameVerifier() { @Override public boolean verify(String hostname, SSLSession session) { return true; } }) .sslSocketFactory(sslParams.sSLSocketFactory, sslParams.trustManager) .build();OkHttpUtils.initClient(okHttpClient); 其中xxxxx.cer为所连接服务器的证书，可从浏览器导出。 也可以通过OpenSSL工具自签名生成，生成方法详见文章Python Web 框架 - CherryPy 通过 HTTPS 发送 Json 消息 123456789String url = \"https://xxxxx\";String json = \"{\\\"key1\\\":\\\"value1\\\", \\\"key1\\\":\\\"value1\\\"}\";OkHttpUtils .postString() .url(url) .content(json) .mediaType(MediaType.parse(\"application/json; charset=utf-8\")) .build() .execute(new MyStringCallback()); 通过 HTTPS 发送同步 POST 请求 123456789101112131415161718192021222324new Thread() { @Override public void run() { String url = \"https://xxxxx\"; Response response; try { response = OkHttpUtils .post() .url(url) .addParams(\"abc\", \"xxx\") .addParams(\"def\", \"yyy\") .build() .execute(); if (response.isSuccessful()) { Log.d(\"OkHTTP\",\"OkHTTP is request success\"); } else { Log.e(\"OkHTTP\", \"OkHTTP is request error\"); } String data=response.body().string(); } catch (IOException e) { e.printStackTrace(); } }}.start(); 同步的 HTTPS 请求不能再主线程中进行，所以要新建一个线程处理同步请求。 通过 HTTPS 发送异步 POST 请求 12345678String url = \"https://xxxxx\";OkHttpUtils .post() .url(url) .addParams(\"abc\", \"xxx\") .addParams(\"def\", \"yyy\") .build() .execute(new MyStringCallback()); Post 表单形式上传文件 1234567OkHttpUtils.post() .addFile(\"file\", \"filename\", file) .url(url) .params(params) .headers(headers) .build() .execute(new MyStringCallback()); 支持上传多个文件，addFile 的第一个参数为文件的 key，即类别表单中 &lt;input type=\"file\" name=\"file\"/&gt; 的 name 属性。 params (params) 和 headers (headers) 可以省略。其中 params (params) 为参数格式，类似 addParams ()。 123Map&lt;String, String&gt; params = new HashMap&lt;&gt;();params.put(\"abc\", \"xxx\");params.put(\"def\", \"yyy\"); 处理返回消息 新建类 MyStringCallback： 123456789101112public class MyStringCallback extends StringCallback{ @Override public void onError(Call call, Exception e, int id) { e.printStackTrace(); } @Override public void onResponse(String response, int id) { Log.i(\"HTTP\", \"onResponse：\" + response); }}","categories":[{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/categories/Android/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/tags/Android/"}]},{"title":"极光推送 JPush 教程","slug":"极光推送JPush教程","date":"2017-03-10T05:37:06.000Z","updated":"2021-09-16T02:56:10.897Z","comments":true,"path":"contents/极光推送JPush教程.html","link":"","permalink":"https://lxmymjr.github.io/contents/%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81JPush%E6%95%99%E7%A8%8B.html","excerpt":"现在很多 Android 或者 iOS 应用都需要服务器推送，有很多第三方应用可以实现此功能，如 Firebase Cloud Messaging (原 Google Cloud Messaging) 和 Apple Push Notifications。由于 Google 官方的推送服务 Firebase Cloud Messaging 不能再中国使用，所以在此介绍极光推送的使用。","text":"现在很多 Android 或者 iOS 应用都需要服务器推送，有很多第三方应用可以实现此功能，如 Firebase Cloud Messaging (原 Google Cloud Messaging) 和 Apple Push Notifications。由于 Google 官方的推送服务 Firebase Cloud Messaging 不能再中国使用，所以在此介绍极光推送的使用。 准备工作 注册成为 JPush 开发者 在 JPush 开发者服务注册账号并登陆。 创建应用 点击 “应用管理” 页面的 “创建应用” 按钮。填写应用名称，应用图标，Android 应用包名（不可更改），iOS 开发证书及密码，iOS 生产证书及密码。 记录 APPKey 和 Master Secret 点击刚创建的应用详情页面，记录 APPKey 和 Master Secret 服务器端 本文使用 Python 作为服务器脚本语言。 官方文档：Python SDK SDK 下载：Python SDK v3.2.4 官方源码：jpush-api-python-client 官方 API：jpush python api 官方 API：REST Push API 环境配置 pip 方式：pip install jpush easy_install 方式：easy_install jpush 使用源码方式：python setup.py install 服务器设置 新建 conf.py 文件： 123# please put your app_key and master_secret hereapp_key = u'your app_key'master_secret = u'your master_secret' 服务端主函数 12345678910111213141516from conf import app_key, master_secret_jpush = jpush.JPush(app_key, master_secret) #初始化jpush_jpush.set_logging(\"DEBUG\") #设置日志push = _jpush.create_push() #初始化pushpush.platform = jpush.all_ #设置推送所有平台push.platform = jpush.platform(*types) #设置推送指定平台，关键字为\"android\", \"ios\",\"winphone\"push.audience = jpush.registration_id(*reg_ids) #根据注册id指定推送设备push.audience = jpush.alias(*alias) #根据别名指定推送设备，别名在开发者服务平台中设置push.audience = jpush.tag(*tag) #根据标签指定推送设备，标签在开发者服务平台中设置，多个标签之间是 OR 的关系，即取并集。push.audience = jpush.tag_and(*tag_ands) #根据标签指定推送设备，标签在开发者服务平台中设置，多个标签之间是 AND 关系，即取交集。push.notification = jpush.notification(alert=None, ios=None, android=None, winphone=None) #指定通知内容，如果下方各平台定义了alert，则覆盖这里的定义ios = jpush.ios(alert=None, badge=None, sound=None, content_available=False, extras=None, sound_disable=False) #指定通知内容，声音，角标，唤醒，扩展字段android = jpush.android(alert, title=None, builder_id=None, extras=None) #指定通知内容，标题，样式，扩展字段push.message = jpush.message(msg_content, title=None, content_type=None, extras=None) #指定消息内容push.smsmessage = jpush.smsmessage(content,delay_time) #指定短信内容和延迟时间（单位为秒，不能超过24小时。设置为0，表示立即发送短信。该参数仅对android平台有效，iOS 和 Winphone平台则会立即发送短信）result = push.send() #执行推送 Android 客户端 官方集成文档：Android SDK 集成指南 官方 API：Android SDK API SDK 下载：Android SDK 目前 SDK 只支持 Android 2.3 或以上版本的手机系统。富媒体信息流功能则需 Android3.0 或以上版本的系统。 jcenter 自动集成步骤 说明：使用 jcenter 自动集成的开发者，不需要在项目中添加 jar 和 so，jcenter 会自动完成依赖；在 AndroidManifest.xml 中不需要添加任何 JPush SDK 相关的配置，jcenter 会自动导入。 确认 android studio 的 Project 根目录的主 gradle 中配置了 jcenter 支持。（新建 project 默认配置就支持） 123456789101112buildscript { repositories { jcenter() } ......}allprojects { repositories { jcenter() }} 在 module 的 gradle 中添加依赖和 AndroidManifest 的替换变量。 1234567891011121314151617181920212223242526272829android { ...... defaultConfig { applicationId \"com.xxx.xxx\" //JPush上注册的包名. ...... ndk { //选择要添加的对应cpu类型的.so库。 abiFilters 'armeabi', 'armeabi-v7a', 'arm64-v8a' // 还可以添加 'x86', 'x86_64', 'mips', 'mips64' } manifestPlaceholders = [ JPUSH_PKGNAME : applicationId, JPUSH_APPKEY : \"你的appkey\", //JPush上注册的包名对应的appkey. JPUSH_CHANNEL : \"自定义渠道名称\", //用户渠道统计的渠道名称 ] ...... } ......}dependencies { ...... compile 'cn.jiguang.sdk:jpush:x.x.x' // 此处为JPush的版本号 compile 'cn.jiguang.sdk:jcore:x.x.x' // 此处为JCore的版本号 ......} 注：如果在添加以上 abiFilter 配置之后 android Studio 出现以下提示： 1NDK integration is deprecated in the current plugin. Consider trying the new experimental plugin. 则在 Project 根目录的 gradle.properties 文件中添加： 1android.useDeprecatedNdk=true 说明：若没有 res/drawable-xxxx/jpush_notification_icon 这个资源默认使用应用图标作为通知 icon，在 5.0 以上系统将应用图标作为 statusbar icon 可能显示不正常，用户可定义没有阴影和渐变色的 icon 替换这个文件，文件名不要变。 初始化 SDK 在主 activity 中： import cn.jpush.android.api.JPushInterface; 在 onCreate 函数中 123JPushInterface.setDebugMode(true); //开启调试JPushInterface.init(this); //初始化rid = JPushInterface.getRegistrationID(getApplicationContext()); //获取Registration ID 接收推送消息 Receiver JPush SDK 收到推送，通过广播的方式，转发给开发者 App，这样开发者就可以灵活地进行处理。 这个动作不是必须的。用户有需要才定义 Receiver 类来处理 SDK 过来的广播。 如果不做这个动作，即不写自定义 Receiver，也不在 AndroidManifest.xml 里配置这个 Receiver，则默认的行为是： 接收到推送的自定义消息，则没有被处理 可以正常收到通知，用户点击打开应用主界面 ### 接受广播 如果全部类型的广播都接收，则需要在 AndroidManifest.xml 里添加如下的配置信息： 12345678910111213&lt;receiver android:name=\"Your Receiver\" android:enabled=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"cn.jpush.android.intent.REGISTRATION\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.MESSAGE_RECEIVED\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.NOTIFICATION_RECEIVED\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.NOTIFICATION_OPENED\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.NOTIFICATION_CLICK_ACTION\" /&gt; &lt;action android:name=\"cn.jpush.android.intent.CONNECTION\" /&gt; &lt;category android:name=\"You package Name\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; ### 开发者自定义 Receiver 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package name;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.os.Bundle;import android.util.Log;import cn.jpush.android.api.JPushInterface;public class MyReceiver extends BroadcastReceiver { private static final String TAG = \"JPush\"; public void onReceive(Context context, Intent intent) { Bundle bundle = intent.getExtras(); Log.d(TAG, \"[MyReceiver] onReceive - \" + intent.getAction()); if (JPushInterface.ACTION_REGISTRATION_ID.equals(intent.getAction())) { String regId = bundle.getString(JPushInterface.EXTRA_REGISTRATION_ID); Log.d(TAG, \"[MyReceiver] 接收Registration Id : \" + regId); //send the Registration Id to your server... } else if (JPushInterface.ACTION_MESSAGE_RECEIVED.equals(intent.getAction())) { Log.d(TAG, \"[MyReceiver] 接收到推送下来的自定义消息: \" + bundle.getString(JPushInterface.EXTRA_MESSAGE)); } else if (JPushInterface.ACTION_NOTIFICATION_RECEIVED.equals(intent.getAction())) { Log.d(TAG, \"[MyReceiver] 接收到推送下来的通知: \" + bundle.getString(JPushInterface.EXTRA_ALERT) + \", extras: \" + bundle.getString(JPushInterface.EXTRA_EXTRA)); int notifactionId = bundle.getInt(JPushInterface.EXTRA_NOTIFICATION_ID); Log.d(TAG, \"[MyReceiver] 接收到推送下来的通知的ID: \" + notifactionId); } else if (JPushInterface.ACTION_NOTIFICATION_OPENED.equals(intent.getAction())) { Log.d(TAG, \"[MyReceiver] 用户点击打开了通知\"); //打开自定义的Activity Intent i = new Intent(context, 需要跳转的activity名称.class); i.putExtras(bundle); //i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP ); context.startActivity(i); } else if (JPushInterface.ACTION_RICHPUSH_CALLBACK.equals(intent.getAction())) { Log.d(TAG, \"[MyReceiver] 用户收到到RICH PUSH CALLBACK: \" + bundle.getString(JPushInterface.EXTRA_EXTRA)); //在这里根据 JPushInterface.EXTRA_EXTRA 的内容处理代码，比如打开新的Activity， 打开一个网页等.. } else if(JPushInterface.ACTION_CONNECTION_CHANGE.equals(intent.getAction())) { boolean connected = intent.getBooleanExtra(JPushInterface.EXTRA_CONNECTION_CHANGE, false); Log.w(TAG, \"[MyReceiver]\" + intent.getAction() +\" connected state change to \"+connected); } else { Log.d(TAG, \"[MyReceiver] Unhandled intent - \" + intent.getAction()); } }}","categories":[{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/categories/Android/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/tags/Android/"}]},{"title":"搭建个人博客教程","slug":"搭建个人博客教程","date":"2017-03-06T04:05:54.000Z","updated":"2021-09-22T12:59:01.218Z","comments":true,"path":"contents/搭建个人博客教程.html","link":"","permalink":"https://lxmymjr.github.io/contents/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B.html","excerpt":"本文参考知乎专栏《教你免费搭建个人博客，Hexo&amp;Github》，感谢作者。 但在实践搭建博客过程中稍有不同。 系统：Windows 7/10 64 位，MacOS；编辑器：sublime text3, Typora；控制台：CMD, Git Bash, Terminal；搭建博客：Hexo+GitHub 用户名：lxmymjr","text":"本文参考知乎专栏《教你免费搭建个人博客，Hexo&amp;Github》，感谢作者。 但在实践搭建博客过程中稍有不同。 系统：Windows 7/10 64 位，MacOS；编辑器：sublime text3, Typora；控制台：CMD, Git Bash, Terminal；搭建博客：Hexo+GitHub 用户名：lxmymjr 安装 进入个人 GitHub 主页，右上角 + 号，选择 new repository，Repository name 填用户名。 安装 Node.js。 Windows 系统直接官网下载安装。 MacOS 系统推荐使用 Homebrew 安装：在 Terminal 中输入 brew install node。 安装 Homebrew：在 Terminal 中输入 1/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 安装 Git。 Windows 系统直接官网下载安装。 MacOS 系统在 Terminal 中输入 brew install git（一般系统自带，可省略此步）。 安装完成后，在开始菜单里找到 \"Git\"-&gt;\"Git Bash\"，输入： $ git config --global user.name \"用户名\" （不要引号） $ git config --global user.email \"注册邮箱\" （不要引号） 名称和注册邮箱是 GitHub 上的（MacOS 无需此步）。 安装 Hexo：输入 $(sudo) npm install -g hexo-cli。 安装 pandoc（MacOS 需要安装）：输入 $ brew install pandoc。 更新 更新 Node.js 版本：在官网上下载安装包覆盖安装。 更新 npm 版本：在命令行或终端中输入 (sudo) npm install npm@latest -g 进行更新，输入 npm -v 查看版本号，在官网中查看最新版本号。 更新 npm package 版本： 命令行或终端中输入 npm outdated 和 npm -g outdated 列出需要更新的版本。 命令行或终端中输入 npm update 和 npm -g update 更新到 outdated 列出 wanted 的版本。 命令行或终端中输入 npm install package-name@latest 强制更新到最新版本。 更新 Hexo 版本：在 Hexo 博客的根目录右键运行 Git Bash 并输入 npm outdated 检查最新版本的模块，确认根目录下有 package.json 文件。根据最新版本的模块检查结果修改 package.json 文件中对应的版本号。删除根目录下的 node_modules 文件夹，然后输入 npm install --save 更新模块。输入 hexo version 检查版本信息。输入 npm outdated -g 检查 Hexo CLI 是否有新版本，如有则输入 npm install -g hexo-cli 进行升级。 配置 新建文件夹 \"Blog\" 作为 Hexo 博客的根目录。 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo i \"文件夹名\"，此处起名为 \"Blog\"。 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo g，生成文章；输入 $ hexo s，启动本地服务器。访问 http://localhost:4000/ 即可查看博客效果。 打开 Git Bash（Windows）/Terminal（MacOS），输入 $(sudo) ssh-keygen -t rsa -C \"GitHub的注册邮箱地址\"，一直回车直到出现信息 Your public key has been saved in /path/to/id_rsa.pub MacOS：先检查 SSH Key 是否已经生成，在 Terminal 上输入 ls -al ~/.ssh 根据路径找到 id_rsa.pub，用 sublime 打开，复制全部内容，然后打开网址（GitHub -&gt;Setting -&gt; SSH and GPG keys），点击 New SSH key 按钮，Title 填写 \"Blog\"，Key 填写刚刚复制的内容，完成后点击 Add SSH key 按钮。 在 Blog 目录下，用 sublime 打开站点配置文件（_config.yml 文件），修改网站相关信息： 12345678title: #网站标题subtitle: #副标题description: #网页描述author: #作者名deploy: type: git repo: https://github.com/\"用户名\"/\"用户名\".github.io.git branch: master #配置部署 发表文章 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo n \"文章标题\"。 在 \"Blog\\_posts\" 目录下找到文章 \"文章标题.md\"，用 sublime 打开，使用 Markdown 语法写文章。 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo g，生成文章。 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo d，会弹出 GitHub Login 窗口，输入你的 GitHub 账号和密码。 然后打开网址：\"用户名\".github.io 就可以看到已经发布的文章了。 删除文章 在 \"Blog\\_posts\" 目录下找到要删除的文章，直接删除。 如果需要删除文章中的本地资源（图片，视频，音频等），需删除 \"Blog\" 目录下的资源，并且删除 \"Blog\" 目录下的资源。 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo g，重新生成文章。 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo d，重新发表文章。 加密访问 使用插件 hexo-blog-encrypt 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ npm install hexo-blog-encrypt --save。 在 Hexo 博客的根目录下的站点配置文件中启用该插件: 123# Securityencrypt: enable: true 在每篇需要加密的文章配置 123password: #设置密码abstract: Enter the password to read. #设置预览内容message: Enter the password to read. #设置提示框内容 定制主题 本博客使用 NexT 主题：详见 GitHub，官网。 安装 NexT: 在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ git clone https://github.com/next-theme/hexo-theme-next themes/next。 如果 hexo 是 5.0.0 以上，则可以直接输入 npm install hexo-theme-next 启用主题：与所有 Hexo 主题启用的模式一样。当安装完成后，打开 Hexo 博客的根目录下的站点配置文件，找到 theme 字段，并将其值更改为 next。在切换主题之后或者更改样式后，最好使用 $ hexo clean 来清除 Hexo 的缓存。 选择 Scheme：Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。 Scheme 的切换通过更改主题配置文件，搜索 scheme 关键字。你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 #去除即可。 设置菜单：NexT 默认的菜单项有（标注的项表示需要手动创建这个页面）： 键值 设定值 显示文本 home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 about about: /about 关于页面 commonweal commonweal: /404.html 公益 404 添加「标签 / 分类」页面：在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ hexo new page tags或者categories。 编辑刚新建的页面，将页面的 type 设置为 tags，主题将自动为这个页面显示分类。页面内容如下： 1234title: 标签/分类date: yyyy-mm-dd hh:mm:sstype: \"tags\"或者type: \"categories\"--- 将post_meta的updated_at字段的值改为true以启动文章修改时间显示。 设置头像：编辑主题配置文件，修改字段 avatar，值设置成头像的链接地址（完整的互联网 URI 或者站点内的地址）。 字数统计：在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ npm install hexo-word-counter --save。编辑 Hexo 博客的根目录下的站点配置文件，新增以下内容到任意位置，然后在主题配置文件中配置 symbols_count_time 项目： 12345678910111213141516# in _config.ymlsymbols_count_time: symbols: true time: true total_symbols: true total_time: true exclude_codeblock: false awl: 4 wpm: 275 suffix: \"mins.\"# in _config.next.ymlsymbols_count_time: separated_meta: true item_text_post: true item_text_total: false 本地搜索功能：在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ npm install hexo-generator-searchdb --save。编辑 Hexo 博客的根目录下的站点配置文件，新增以下内容到任意位置，然后在主题配置文件中配置 local_search 项目： 12345search: path: search.xml field: post format: html limit: 10000 新建 Blog/source/_data/styles.styl 文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// Custom styles.//修改右上角xmliu's blog颜色及高度.site-brand-container { background: #0080FF;}.site-meta { background: #0080FF; padding: 0 5px;}//扩大左侧栏.sidebar { width: 300px;}//去掉目录中Home和Search上下的空白.menu { padding: 0em 0;}//减少主界面文章标题和预览之间距离.posts-expand .post-header { margin: 10px 0 10px 0;}//减少主界面文章预览和Read more按钮之间距离.post-button { margin-top: 10px;}//将background.jpg放在node_modules\\hexo-theme-next\\source\\images目录下body { background: url(/images/background.jpg); background-attachment: fixed;}//页面底部文字变白色.footer { color: white;}//Archive界面//去掉title.posts-collapse .collection-title { display: none;}//去掉年份上下空白.posts-collapse .post-content .collection-year { margin: 0;}//去掉标题上下空白.posts-collapse .post-content .post-header { margin: 0;}//减少左边距.posts-collapse .post-content { margin: 0;}//取消整栏上下空白.post-block { padding-top: 20px padding-bottom: 20px}@media (min-width: 1200px) { //缩小两边距离 .main { width: 1360px; } //扩大主内容栏 .main-inner { width: calc(100% - 312px); } //扩大左侧栏 .header-inner { width: 300px; }} SEO 优化指南 方便搜索引擎收录本博客，参考文章基于 Hexo 中 Next 主题的 SEO 优化指南，Hexo 插件之百度主动提交链接 生成站点地图提交到 Google 需要先安装 hexo-generator-sitemap 插件，在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ npm install hexo-generator-sitemap --save。 然后编辑 Hexo 博客的根目录下的站点配置文件，新增以下内容到任意位置： 12sitemap: path: sitemap.xml 安装完这个插件，再重启hexo（hexo g），就能生成sitemap.xml文件了。 进入Google Search Console的网址前缀，输入本博客的网址，选择“其他验证方法”中的“HTML标记”，复制其中的元标记到your-hexo-site\\themes\\next\\layout\\_partials\\head\\head.swig中的line5或者将验证码复制到主题配置文件中的google_site_verification字段中。 然后进行验证，然后在控制台中提交站点地图文件。 生成网址提交到百度 因为 GitHub 禁止百度爬虫访问博客，导致博客无法被百度收录。 注册百度站长工具，提交你的站点网址，即网站的根地址。然后在工具 -&gt; 网页抓取 -&gt; 链接提交里找到密钥。 格式：http://data.zz.baidu.com/urls?site=&lt;your website&gt;&amp;token=&lt;your token&gt; 接下来需要安装 hexo-baidu-url-submit 插件：在 Hexo 博客的根目录右键运行 Git Bash 并输入：$ npm install hexo-baidu-url-submit --save。 然后编辑 Hexo 博客的根目录下的站点配置文件，新增以下内容到任意位置： 12345baidu_url_submit: count: n # 提交最新的n个链接 host: # &lt;你的网站根地址&gt; token: your_token # 上述获得的密钥 path: baidu_urls.txt # 所需提交的网址的存放文件 注意，此插件的配置文件中包含密钥，请妥善管理好博客源码。 可以把源码保存在本地，如果要托管在 git 仓库里，请选择私有仓库。 最后，加入新的 deployer: 12345deploy:- type: git repo: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master- type: baidu_url_submitter 注意type前面一定有一个短横线。 hexo generate 会产生一个文本文件，里面包含所需百度检索的链接。 hexo deploy 会从上述文件中读取链接，提交至百度搜索引擎。 添加蜘蛛协议 在站点 source 文件夹下新建 robots.txt 文件，文件内容如下： 12345678910111213# hexo robots.txtUser-agent: * Allow: /Allow: /archives/Allow: /tags/Allow: /categories/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: https://lxmymjr.github.io/sitemap.xml #改成你自己的网址 网站结构优化 keywords 和 description 在.md 中添加如下代码，用于生成的文章中添加关键字和描述。 keywords: description: 修改文章链接 Hexo 默认的文章链接形式为 domain/year/month/day/postname，即一个四级 url，可能造成 url 过长，对搜索引擎十分不友好。 所以需要改成 domain/postname 的形式。编辑站点配置文件，修改其中的 permalink 字段，改为 permalink: :title.html 即可。 不同电脑维护博客 使用第三方 git 服务进行博客的备份。可以用 GitHub 的私有仓库。 在 GitHub 网站创建一个新的 repository，我们在这里给新创建的 repository 命名为 Blog。 在原电脑中从本地上传 Hexo 到 GitHub 仓库 初始化仓库。 在 Hexo 博客的根目录右键运行 Git Bash 并输入以下命令： $ git init $ git remote add origin &lt;server address&gt; #server address为备份仓库的地址（https://github.com/\"用户名\"/Blog) 把主题配置文件 Blog/node_modules/hexo-theme-next/_config.yml 复制到 Blog/source/_data/ 文件夹里面。 把本地文件同步到 GitHub 上面。 分别输入执行以下命令： $ git add . #添加所有目录，注意add后面有个点 $ git commit -m \"add to GitHub\" #引号内为提交说明，每次提交都需要 $ git push origin master #把更新推送到云端 可以登录 GitHub 账户查看刚创建的 blog 仓库中是否上传成功。 windows 平台 push 过程中会提示输入 GitHub 的用户名和的密码。 在新电脑中从 GitHub 仓库取回 Hexo 到本地。 安装 Git 和 Node.js（见上）。 把文件取回本地。 安装环境完成后，在新 Blog 文件夹下运行 Git Bash 并分别执行以下几条命令： $ git init $ git remote add origin &lt;server address&gt; #server address为备份仓库的地址（https://github.com/\"用户名\"/Blog) $ git pull origin master 运行完 pull 命令后你会发现文件夹中就会出现刚刚上传的内容。 配置新的 Hexo。 3.1. 在刚才的目录下执行以下命令以在新电脑中安装 Hexo。 $ (sudo) npm install -g hexo-cli 3.2. 初始化 Hexo 并安装相应依赖包。 $ (sudo) npm install #会根据package.json文件中的依赖列表安装相应依赖包 3.3. 将 Blog/source/_data/background.jpg 复制到 Blog/node_modules-theme-next。 3.4. 输入命令 $ hexo g 和命令 $ hexo s，然后在浏览器输入 localhost:4000 中进行预览。如果没有问题那么新电脑上就配置成功了。 3.5. 发表文章的操作同原电脑（见上）。 把新电脑上的 Hexo 从本地同步到 GitHub 仓库。 当发表完文章，我们还需要把 Hexo 程序同步到我们 GitHub 的 blog 仓库。执行下面指令： $ git add . 这时候可以输入命令 $ git status 查看状态，回显示刚才编辑过的文件的信息。 之后分别输入下面指令完成上传： $ git commit -m \"add to GitHub\" $ git push origin master 成功后，我们再次把程序同步更新到了我们的 GitHub 仓库 Blog。 新旧电脑继续维护博客 如果再想用旧电脑更新博客，只需要在执行添加文章之前先把程序从 Blog 仓库拉取下来便可。输入命令： $ git pull 现在无论用哪台电脑进行修改等操作，都需先输入命令 $ git pull，然后再进行修改等操作，修改等操作完成后，输入执行以下命令：$ git add . 和 $ git commit -m \"add to GitHub\" 和 $ git push origin master 来更新远程仓库。 Markdown 基本语法 一个井号#一级标题，n 个井号 n 级标题，注意：井号和标题名之间一定要有一个空格。 代码，一对 `表示行内代码，一对``` 表示行间代码，第一个 ``` 后可加上语言名。 一对星号表示斜体，两对星号表示加粗，三对星号表示斜体加粗，一对下划线表示斜体，两对下划线表示加粗，三对下划线表示斜体加粗。 [链接名称](链接地址) 插入链接。 &gt; 表示引用。 用全角空格表示缩进，搜狗输入法中 shift+空格切换全角半角。 字体颜色：&lt;font color=颜色&gt;内容&lt;/font&gt;。 一行中用三个以上的星号、减号、下划线来建立一个分隔线，行内不能有其他东西。也可以在星号、减号、下划线中间插入空格。 插入图片 在 Hexo 博客的根目录下的 source 文件夹中新建文件夹 image。 在 Markdown 中写：![\"图片描述\"](\\image\\图片名字.图片格式) 或者 ![\"图片描述\"](外链网址)。 或者在 Markdown 中写： 1{% img /image/图片名字.图片格式 图片宽度 图片高度 %} 或者 1{% img 外链网址 图片宽度 图片高度 %} 插入视频 在 Hexo 博客的根目录右键运行 Git Bash 并输入：npm install hexo-tag-dplayer --save。 在 Markdown 中写： 1{% dplayer \"url=\"视频网址\" \"theme=#FADFA3\" \"autoplay=false\" %} 如果插入本地视频，则先在 Hexo 博客的根目录下的 source 文件夹中新建文件夹 video，然后在 Markdown 中视频地址为。视频格式。 插入公式 在 Markdown 中写：&lt;img src=\"http://chart.googleapis.com/chart?cht=tx&amp;chl=\\Large \"LaTeX格式的公式代码\"\" style=\"border:none;\"&gt;。 NexT 主题自带 MathJax 功能，在主题配置文件中配置 math 项目。 如果启用了 per_page 功能，则需要在每篇需要 MathJax 的文章配置 mathjax : true。 如果插入行内公式，在 Markdown 中写：$LaTeX格式的公式代码$。如果插入行间公式，在 Markdown 中写：$$LaTeX格式的公式代码$$。 打开 hexo 渲染器。 在 Hexo 博客的根目录右键运行 Git Bash 并输入：npm un hexo-renderer-marked --save 和 npm i hexo-renderer-pandoc --save # 或者 hexo-renderer-kramed 如果用 hexo-renderer-pandoc 则需要在系统里提前安装好 pandoc 如果需要回车换行功能的话，则需要编辑 Hexo 博客的根目录下的站点配置文件，新增以下内容到任意位置： 123pandoc: extensions: - \"+hard_line_breaks\" 注意：如果 Windows 电脑安装了 Anaconda3 的话，因为 Anaconda3 自带了 pandoc（C:\\ProgramData\\Anaconda3\\pkgs\\pandoc-1.19.2.1-hb2460c7_1\\Scripts\\pandoc.exe）且版本落后，需要在系统 - 高级系统设置 - 环境变量 - 系统变量的 Path 变量中将新安装的 Pandoc 路径移到 Anaconda 路径上方，并通过 pandoc --version 进行验证。 让 Hexo 在使用 Mathjax 时支持多行公式：\\\\ 符号表示换行，&amp; 表示对齐，\\begin{split} 表示等号对齐，\\begin{align} 表示向左对齐，\\begin{gather} 表示居中对齐。 例： $\\begin{split}a&amp;=b+c-d\\\\&amp;\\quad+e-f\\\\&amp;=g+h\\\\&amp;=i\\end{split}$ \\(\\begin{split}a&amp;=b+c-d\\\\&amp;\\quad+e-f\\\\&amp;=g+h\\\\&amp;=i\\end{split}\\) $\\begin{align}a_{11}&amp;=b_{11}&amp;a_{12}&amp;=b_{12}\\\\a_{21}&amp;=b_{21}+c_{21}&amp;a_{22}&amp;=b_{22}\\end{align}$ \\(\\begin{align}a_{11}&amp;=b_{11}&amp;a_{12}&amp;=b_{12}\\\\a_{21}&amp;=b_{21}+c_{21}&amp;a_{22}&amp;=b_{22}\\end{align}\\) $\\begin{gather}a_{11}=b_{11}&amp;a_{12}=b_{12}\\\\a_{21}=b_{21}+c_{21}&amp;a_{22}=b_{22}\\end{gather}$ \\(\\begin{gather}a_{11}=b_{11}&amp;a_{12}=b_{12}\\\\a_{21}=b_{21}+c_{21}&amp;a_{22}=b_{22}\\end{gather}\\) 看到别的网站上有 MathJax 解析的公式时，可以通过右键菜单 “Show Math As&gt; TeX Commands” 查看 LaTex 格式。 希腊字母表示方法： 部分字母变体 \\epsilon \\varepsilon \\phi \\varphi：\\(\\epsilon \\varepsilon \\phi \\varphi\\)。 上标和下标： 使用符号 ^（上标）和_（下标），如 x_i^j：\\(x_i^j\\)。 如果上标或者下标包含不止一个字符，则需要用括号 {} 括起来。 在 markdown 中书写，因为 \\, $, {, }, _都是有特殊含义的，所以需要加 \\ 转义。 括号： 小括号与中括号：使用原始的 \\(()\\)，\\([]\\) 即可。 大括号：由于大括号 \\(\\{\\}\\) 被用来分组，因此需要使用 \\{和 \\} 表示大括号，还可以使用 \\lbrace 和 \\rbrace 来表示。 尖括号：使用 \\langle 和 \\rangle 表示 \\(\\langle\\) 左尖括号和 \\(\\rangle\\) 右尖括号。 上取整：使用 \\(\\lceil \\rceil\\)。 下取整：使用 \\(\\lfloor \\rfloor\\)。 需要注意的是，原始符号并不会随着公式大小缩放，可以使用 \\left(…\\right) 来自适应的调整括号大小。 分式与根式 (分号与开方)： \\frac ab 显示为 \\(\\frac ab\\)，而 \\frac{a+b}{c+d} 显示为 \\(\\frac{a+b}{c+d}\\)。 或者用 {a+b\\over c+d} 为 \\({a+b\\over c+d}\\)。 \\sqrt[y]{x} 表示开方 \\(\\sqrt[y]{x}\\)。 字体： mathbb 和 Bbb：\\(\\mathbb {ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}\\) 黑板体 mathbf：\\(\\mathbf {ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}\\) 粗体 mathtt：\\(\\mathtt {ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}\\) 打印体 mathrm：\\(\\mathrm {ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}\\) 罗马体 mathcal：\\(\\mathcal {ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}\\) 花体 mathscr：\\(\\mathscr {ABCDEFGHIJKLMNOPQRSTUVWXYZ}\\) 手写体 mathfrak：\\(\\mathfrak {ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz}\\) 德国体 数学符号： 求和：\\sum \\(\\sum\\)，可使用上下标。 积分：\\int\\(\\int\\)，可使用上下限。 连乘：\\prod\\(\\prod\\) 二重积分：\\iint\\(\\iint\\) 极限：\\lim\\(\\lim\\)，可以使用下标。 比较：\\lt \\gt \\le \\ge \\neq\\(\\lt \\gt \\le \\ge \\neq\\)。可以前面加 \\not 否定 \\(\\not\\lt \\not\\gt \\not\\le \\not\\ge \\not\\neq\\)。 运算：\\times \\div \\pm \\mp\\(\\times \\div \\pm \\mp\\)，\\cdot\\(\\cdot\\) 点乘。 集合：\\cup \\cap \\bigcup \\bigcap \\setminus \\subset \\subseteq \\subsetneq \\supset \\in \\notin \\emptyset \\varnothing\\(\\cup \\cap \\bigcup \\bigcap \\setminus \\subset \\subseteq \\subsetneq \\supset \\in \\notin \\emptyset \\varnothing\\) 排列：\\choose 或 \\binom,{x \\choose y}\\({x \\choose y}\\) 或者 \\binom{x}{y}\\(\\binom{x}{y}\\) 箭头：\\to \\rightarrow \\leftarrow \\Rightarrow \\Leftarrow \\mapsto \\implies \\iff \\longrightarrow\\(\\to \\rightarrow \\leftarrow \\Rightarrow \\Leftarrow \\mapsto \\implies \\iff \\longrightarrow\\) 逻辑：\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash\\(\\land \\lor \\lnot \\forall \\exists \\top \\bot \\vdash \\vDash\\) 空格：\\quad 和 \\qquad，MathJax 自己决定是否增加空格，所以一般的空格是没用的。 特殊点号：\\star \\ast \\oplus \\circ \\bullet\\(\\star \\ast \\oplus \\circ \\bullet\\) 等号：\\approx \\sim \\cong \\equiv \\prec\\(\\approx \\sim \\cong \\equiv \\prec\\) 特殊算符：\\infty \\aleph_0 \\nabla \\partial \\Im \\Re\\(\\infty \\aleph_0 \\nabla \\partial \\Im \\Re\\) 模运算：a\\equiv b\\pmod n\\(a\\equiv b\\pmod n\\) 加多个数：\\cdots\\(a_1+a_2+\\cdots+a_n\\) 分隔多个数：\\ldots\\(a_1, a_2, \\ldots ,a_n\\) 头部标：\\hat \\widehat \\bar \\overline \\vec \\overrightarrow \\dot \\ddot\\(\\hat x \\widehat x \\bar x \\overline{xyz} \\vec x \\overrightarrow{xyz} \\dot x \\ddot x\\) 表格： 使用 \\begin{array}{列样式}…\\end{array} 的形式来创建表格，列样式可以是 c,l,r 表示居中，左，右对齐，还可以使用 | 表示一条竖线。表格中各行使用 \\ 分隔 (hexo markdown 中，需要使用 \\\\)，各列使用 &amp; 分隔。使用。 123456\\begin{array}{c|lcr}n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\\\hline1 &amp; 1 &amp; 2 &amp; 3 \\\\2 &amp; 4 &amp; 5 &amp; 6 \\\\3 &amp; 7 &amp; 8 &amp; 9 \\\\\\end{array} \\[\\begin{array}{c|lcr} n &amp; \\text{Left} &amp; \\text{Center} &amp; \\text{Right} \\\\ \\hline 1 &amp; 1 &amp; 2 &amp; 3 \\\\ 2 &amp; 4 &amp; 5 &amp; 6 \\\\ 3 &amp; 7 &amp; 8 &amp; 9 \\\\ \\end{array}\\] 矩阵： 使用 \\begin{matrix}…\\end{matrix} 的形式来表示矩阵，在 \\begin 与 \\end 之间加入矩阵中的元素即可。矩阵的行之间使用 \\ 分隔 (hexo markdown 中，需要使用 \\\\)，列之间使用 &amp; 分隔。 12345\\begin{matrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6 \\\\7 &amp; 8 &amp; 9 \\\\\\end{matrix} \\[\\begin{matrix} 1 &amp; 2 &amp; 3 \\\\ 4 &amp; 5 &amp; 6 \\\\ 7 &amp; 8 &amp; 9 \\\\ \\end{matrix}\\] 如果要对矩阵加括号，可以像上文中提到的一样，使用 \\left 与 \\right 配合表示括号符号。也可以使用特殊的 matrix。即替换 begin{matrix}…end{matrix} 中的 matrix 为 pmatrix，bmatrix，Bmatrix，vmatrix,Vmatrix。 内联矩阵：\\bigl(\\begin{smallmatrix} ... \\end{smallmatrix}\\bigr)\\(\\bigl( \\begin{smallmatrix} a &amp; b \\\\ c &amp; d \\end{smallmatrix} \\bigr)\\) 可以使用 \\(\\cdots\\)\\(\\ddots\\)\\(\\vdots\\) 来省略矩阵中的元素，如： \\[\\begin{pmatrix} 1 &amp; a_1 &amp; a_1^2 &amp; \\cdots &amp; a_1^n \\\\ 1 &amp; a_2 &amp; a_2^2 &amp; \\cdots &amp; a_2^n \\\\ \\vdots &amp; \\vdots&amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; a_m &amp; a_m^2 &amp; \\cdots &amp; a_m^n \\end{pmatrix}\\] 分类表达式： 定义函数的时候经常需要分情况给出表达式，可使用 \\begin{cases}…\\end{cases}。其中，使用 \\ 来分类，使用 &amp; 指示需要对齐的位置。如： \\[f(n) = \\begin{cases} a, &amp; \\text{if $n$ is even} \\\\ b, &amp; \\text{if $n$ is odd} \\\\ \\end{cases}\\] 空间问题： 不要在指数或者积分中使用 \\frac： 在指数或者积分表达式中使用 \\frac 会使表达式看起来不清晰，因此在专业的数学排版中很少被使用。应该使用一个水平的 / 来代替，效果如下： \\[\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\\\ \\hline \\\\ e^{i\\frac{\\pi}2} \\quad e^{\\frac{i\\pi}2}&amp; e^{i\\pi/2} \\\\ \\int_{-\\frac\\pi2}^\\frac\\pi2 \\sin x\\,dx &amp; \\int_{-\\pi/2}^{\\pi/2}\\sin x\\,dx \\\\ \\end{array}\\] 使用 \\mid 代替 | 作为分隔符： 符号 | 作为分隔符时有排版空间大小的问题，应该使用 \\mid 代替。效果如下： \\[\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\\\ \\hline \\\\ {x|x^2\\in\\Bbb Z} &amp; {x\\mid x^2\\in\\Bbb Z} \\\\ \\end{array}\\] 此外，在微分前应该使用 \\, 来增加些许空间，否则 LaTex 会将微分紧凑地排列在一起。如下： \\[\\begin{array}{cc} \\mathrm{Bad} &amp; \\mathrm{Better} \\\\ \\hline \\\\ \\iiint_V f(x)dz dy dx &amp; \\iiint_V f(x)\\,dz\\,dy\\,dx \\end{array}\\] 连分数： 书写连分数表达式时，请使用 \\cfrac 代替 \\frac 或者 \\over 两者效果对比如下： \\[x = a_0 + \\frac{1^2}{a_1 + \\frac{2^2}{a_2 + \\frac{3^2}{a_3 + \\frac{4^4}{a_4 + \\cdots}}}} \\tag{\\frac}\\] \\[x = a_0 + \\cfrac{1^2}{a_1 + \\cfrac{2^2}{a_2 + \\cfrac{3^2}{a_3 + \\cfrac{4^4}{a_4 + \\cdots}}}} \\tag{\\cfrac}\\] 方程组： 使用 \\begin{array} … \\end{array} 与 \\left{…\\right. 配合，表示方程组，如： \\[\\begin{array}{c} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{array}\\] 同时，还可以使用 \\begin{cases}…\\end{cases} 表达同样的方程组，如： \\[\\begin{cases} a_1x+b_1y+c_1z=d_1 \\\\ a_2x+b_2y+c_2z=d_2 \\\\ a_3x+b_3y+c_3z=d_3 \\end{cases}\\] 对齐方程组中的 = 号，可以使用 \\being{aligned} .. \\end{aligned}，如： \\[\\begin{aligned} a_1x+b_1y+c_1z &amp;=d_1+e_1 \\\\ a_2x+b_2y&amp;=d_2 \\\\ a_3x+b_3y+c_3z &amp;=d_3 \\end{aligned}\\] 如果要对齐 = 号和项，可以使用 \\being{array}{列样式} .. \\end{array}，如： \\[\\begin{array}{ll} a_1x+b_1y+c_1z &amp;=d_1+e_1 \\\\ a_2x+b_2y &amp;=d_2 \\\\ a_3x+b_3y+c_3z &amp;=d_3 \\end{array}\\] 颜色： 命名颜色是浏览器相关的，如果浏览器没有定义相关的颜色名称，则相关文本将被渲染为黑色。以下颜色是 HTML4 与 CSS2 标准中定义的一些颜色，其应该被大多数浏览器定义了。 \\[\\begin{array}{|rc|} \\hline \\verb+\\color{black}{text}+ &amp; \\color{black}{text} \\\\ \\verb+\\color{gray}{text}+ &amp; \\color{gray}{text} \\\\ \\verb+\\color{silver}{text}+ &amp; \\color{silver}{text} \\\\ \\verb+\\color{white}{text}+ &amp; \\color{white}{text} \\\\ \\hline \\verb+\\color{maroon}{text}+ &amp; \\color{maroon}{text} \\\\ \\verb+\\color{red}{text}+ &amp; \\color{red}{text} \\\\ \\verb+\\color{yellow}{text}+ &amp; \\color{yellow}{text} \\\\ \\verb+\\color{lime}{text}+ &amp; \\color{lime}{text} \\\\ \\verb+\\color{olive}{text}+ &amp; \\color{olive}{text} \\\\ \\verb+\\color{green}{text}+ &amp; \\color{green}{text} \\\\ \\verb+\\color{teal}{text}+ &amp; \\color{teal}{text} \\\\ \\verb+\\color{aqua}{text}+ &amp; \\color{aqua}{text} \\\\ \\verb+\\color{blue}{text}+ &amp; \\color{blue}{text} \\\\ \\verb+\\color{navy}{text}+ &amp; \\color{navy}{text} \\\\ \\verb+\\color{purple}{text}+ &amp; \\color{purple}{text} \\\\ \\verb+\\color{fuchsia}{text}+ &amp; \\color{magenta}{text} \\\\ \\hline \\end{array}\\] 此外，HTML5 与 CSS3 也定义了一些颜色名称。同时，颜色也可以使用 #rgb 的形式来表示，r、g、b 分别表示代表颜色值得 16 进制数，如：\\color{\\#0F0}{text}。更多点击 HTML 色彩快速参考手册或 CSS 色彩快速参考手册。 删除线： \\[\\require{cancel}\\begin{array}{rl} \\verb|y+\\cancel{x}| &amp; y+\\cancel{x}\\\\ \\verb|\\cancel{y+x}| &amp; \\cancel{y+x}\\\\ \\verb|y+\\bcancel{x}| &amp; y+\\bcancel{x}\\\\ \\verb|y+\\xcancel{x}| &amp; y+\\xcancel{x}\\\\ \\verb|y+\\cancelto{0}{x}| &amp; y+\\cancelto{0}{x}\\\\ \\verb+\\frac{1\\cancel9}{\\cancel95} = \\frac15+&amp; \\frac{1\\cancel9}{\\cancel95} = \\frac15 \\\\ \\end{array}\\] \\[\\require{enclose}\\begin{array}{rl} \\verb|\\enclose{horizontalstrike}{x+y}| &amp; \\enclose{horizontalstrike}{x+y}\\\\ \\verb|\\enclose{verticalstrike}{\\frac xy}| &amp; \\enclose{verticalstrike}{\\frac xy}\\\\ \\verb|\\enclose{updiagonalstrike}{x+y}| &amp; \\enclose{updiagonalstrike}{x+y}\\\\ \\verb|\\enclose{downdiagonalstrike}{x+y}| &amp; \\enclose{downdiagonalstrike}{x+y}\\\\ \\verb|\\enclose{horizontalstrike,updiagonalstrike}{x+y}| &amp; \\enclose{horizontalstrike,updiagonalstrike}{x+y}\\\\ \\end{array}\\] 参考资料： 在 Hexo 中使用 MathJax 插入数学公式 MathJax basic tutorial and quick reference - StackExchange MathJax Docs Easy Copy MathJax 常用数学符号的 LaTeX 表示方法 Some Tips $ hexo g 和 $ hexo d 可以合写为 $ hexo g -d。 $ git add . 和 $ git commit -m \"add to GitHub\" 可以合写为 $ git commit -a -m \"add to GitHub\"（简写后不会提交新建的文件，只会更新旧文件的修改）。 如果不改变本地和远程仓库的结构且 push 的源仓库、分支与目的仓库、分支相同，push 后面的变量均可省略，$ git push 即可。","categories":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/categories/Tutorial/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/categories/Python/"},{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/categories/Tutorial/"},{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/categories/Android/"}],"tags":[{"name":"Tutorial","slug":"Tutorial","permalink":"https://lxmymjr.github.io/tags/Tutorial/"},{"name":"Python","slug":"Python","permalink":"https://lxmymjr.github.io/tags/Python/"},{"name":"Data Analysis","slug":"Data-Analysis","permalink":"https://lxmymjr.github.io/tags/Data-Analysis/"},{"name":"Crawler","slug":"Crawler","permalink":"https://lxmymjr.github.io/tags/Crawler/"},{"name":"Android","slug":"Android","permalink":"https://lxmymjr.github.io/tags/Android/"},{"name":"Web Framework","slug":"Web-Framework","permalink":"https://lxmymjr.github.io/tags/Web-Framework/"},{"name":"Examples","slug":"Examples","permalink":"https://lxmymjr.github.io/tags/Examples/"}]}